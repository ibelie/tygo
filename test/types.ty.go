// Generated by tygo.  DO NOT EDIT!

package test

import "fmt"
import "github.com/ibelie/tygo"
import "log"
import "math"

type Corpus uint

const (
	Corpus_UNIVERSAL Corpus = 0
	Corpus_WEB       Corpus = 1
	Corpus_IMAGES    Corpus = 2
	Corpus_LOCAL     Corpus = 3
	Corpus_NEWS      Corpus = 4
	Corpus_PRODUCTS  Corpus = 5
	Corpus_VIDEO     Corpus = 6
)

func (i Corpus) String() string {
	switch i {
	case Corpus_UNIVERSAL:
		return "UNIVERSAL"
	case Corpus_WEB:
		return "WEB"
	case Corpus_IMAGES:
		return "IMAGES"
	case Corpus_LOCAL:
		return "LOCAL"
	case Corpus_NEWS:
		return "NEWS"
	case Corpus_PRODUCTS:
		return "PRODUCTS"
	case Corpus_VIDEO:
		return "VIDEO"
	default:
		panic(fmt.Sprintf("[Tygo][Corpus] Unexpect enum value: %d", i))
		return "UNKNOWN"
	}
}

func (i Corpus) ByteSize() (size int) {
	if i != 0 {
		size = tygo.SizeVarint(uint64(i))
	}
	return
}

func (i Corpus) CachedSize() int {
	return i.ByteSize()
}

func (i Corpus) Serialize(output *tygo.ProtoBuf) {
	if i != 0 {
		output.WriteVarint(uint64(i))
	}
}

func (i *Corpus) Deserialize(input *tygo.ProtoBuf) (err error) {
	x, err := input.ReadVarint()
	*i = Corpus(x)
	return
}

type Vector2 struct {
	tygo.Tygo
	X float32 // float32
	Y float64 // fixedpoint<1, -10>
	B []byte  // bytes
	S string  // string
	E Corpus  // Corpus
	P *GoType // *GoType
}

func (s *Vector2) MaxFieldNum() int {
	return 6
}

func (s *Vector2) ByteSize() (size int) {
	if s != nil {
		// property: s.X
		// type: float32
		if s.X != 0 {
			size += 1 + 4
		}

		// property: s.Y
		// type: fixedpoint<1, -10>
		if s.Y != -10 {
			size += 1 + tygo.SizeVarint(uint64((s.Y + 10) * 10))
		}

		// property: s.B
		// type: bytes
		if len(s.B) > 0 {
			l := len([]byte(s.B))
			size += 1 + tygo.SizeVarint(uint64(l)) + l
		}

		// property: s.S
		// type: string
		if len(s.S) > 0 {
			l := len([]byte(s.S))
			size += 1 + tygo.SizeVarint(uint64(l)) + l
		}

		// property: s.E
		// type: Corpus
		if s.E != 0 {
			size += 1 + tygo.SizeVarint(uint64(s.E))
		}

		// property: s.P
		// type: *GoType
		if s.P != nil {
			tmp := s.P.ByteSize()
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

	}
	s.SetCachedSize(size)
	return
}

func (s *Vector2) Serialize(output *tygo.ProtoBuf) {
	if s != nil {
		// property: s.X
		// type: float32
		if s.X != 0 {
			output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
			output.WriteFixed32(math.Float32bits(s.X))
		}

		// property: s.Y
		// type: fixedpoint<1, -10>
		if s.Y != -10 {
			output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
			output.WriteVarint(uint64((s.Y + 10) * 10))
		}

		// property: s.B
		// type: bytes
		if len(s.B) > 0 {
			output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
			output.WriteBuf([]byte(s.B))
		}

		// property: s.S
		// type: string
		if len(s.S) > 0 {
			output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
			output.WriteBuf([]byte(s.S))
		}

		// property: s.E
		// type: Corpus
		if s.E != 0 {
			output.WriteBytes(40) // tag: 40 MAKE_TAG(5, WireVarint=0)
			output.WriteVarint(uint64(s.E))
		}

		// property: s.P
		// type: *GoType
		if s.P != nil {
			output.WriteBytes(50) // tag: 50 MAKE_TAG(6, WireBytes=2)
			output.WriteVarint(uint64(s.P.CachedSize()))
			s.P.Serialize(output)
		}

	}
}

func (s *Vector2) Deserialize(input *tygo.ProtoBuf) (err error) {
object_tmp_1:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(127); err != nil {
			return
		} else if cutoff {
		switch_tmp_1:
			switch tag >> 3 {
			// property: s.X
			case 1:
				if tag == 13 { // MAKE_TAG(1, WireFixed32=5)
					// type: float32
					if x, e := input.ReadFixed32(); e == nil {
						s.X = math.Float32frombits(x)
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(16) { // tag: 16 MAKE_TAG(2, WireVarint=0)
						continue object_tmp_1 // next tag for Vector2
					}
					tag = 16 // MAKE_TAG(2, WireVarint=0) // fallthrough case 2
				} else {
					break switch_tmp_1 // skip tag
				}
				fallthrough
			// property: s.Y
			case 2:
				if tag == 16 { // MAKE_TAG(2, WireVarint=0)
					// type: fixedpoint<1, -10>
					if x, e := input.ReadVarint(); e == nil {
						s.Y = float64(x) / 10 - 10
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(26) { // tag: 26 MAKE_TAG(3, WireBytes=2)
						continue object_tmp_1 // next tag for Vector2
					}
					tag = 26 // MAKE_TAG(3, WireBytes=2) // fallthrough case 3
				} else {
					break switch_tmp_1 // skip tag
				}
				fallthrough
			// property: s.B
			case 3:
				if tag == 26 { // MAKE_TAG(3, WireBytes=2)
					// type: bytes
					if x, e := input.ReadBuf(); e == nil {
						s.B = make([]byte, len(x))
						copy(s.B, x)
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(34) { // tag: 34 MAKE_TAG(4, WireBytes=2)
						continue object_tmp_1 // next tag for Vector2
					}
					tag = 34 // MAKE_TAG(4, WireBytes=2) // fallthrough case 4
				} else {
					break switch_tmp_1 // skip tag
				}
				fallthrough
			// property: s.S
			case 4:
				if tag == 34 { // MAKE_TAG(4, WireBytes=2)
					// type: string
					if x, e := input.ReadBuf(); e == nil {
						s.S = string(x)
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(40) { // tag: 40 MAKE_TAG(5, WireVarint=0)
						continue object_tmp_1 // next tag for Vector2
					}
					tag = 40 // MAKE_TAG(5, WireVarint=0) // fallthrough case 5
				} else {
					break switch_tmp_1 // skip tag
				}
				fallthrough
			// property: s.E
			case 5:
				if tag == 40 { // MAKE_TAG(5, WireVarint=0)
					// type: Corpus
					if x, e := input.ReadVarint(); e == nil {
						s.E = Corpus(x)
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(50) { // tag: 50 MAKE_TAG(6, WireBytes=2)
						continue object_tmp_1 // next tag for Vector2
					}
					tag = 50 // MAKE_TAG(6, WireBytes=2) // fallthrough case 6
				} else {
					break switch_tmp_1 // skip tag
				}
				fallthrough
			// property: s.P
			case 6:
				if tag == 50 { // MAKE_TAG(6, WireBytes=2)
					// type: *GoType
					if x, e := input.ReadBuf(); e == nil {
						if s.P == nil {
							s.P = &GoType{}
						}
						if len(x) > 0 {
							if err = s.P.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if input.ExpectEnd() {
						break object_tmp_1 // end for Vector2
					}
					continue object_tmp_1 // next tag for Vector2
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

type Fighter_Part1 struct {
	tygo.Tygo
	Pos     *Vector2           // *Vector2
	IsAwake bool               // bool
	Hp      float32            // float32
	Poss    map[int32]*Vector2 // map[int32]*Vector2
	Posi    map[int32]float32  // map[int32]float32
	Posl    []*Vector2         // []*Vector2
	Posll   [][]*Vector2       // [][]*Vector2
	Pyl     []*GoType          // []*GoType
	Pyd     map[int32]*GoType  // map[int32]*GoType
	Pyv1    interface{}        // variant<int32, *GoType>
	Pyv2    interface{}        // variant<int32, *GoType>
}

func (s *Fighter_Part1) MaxFieldNum() int {
	return 11
}

func (s *Fighter_Part1) ByteSize() (size int) {
	if s != nil {
		// property: s.Pos
		// type: *Vector2
		if s.Pos != nil {
			tmp := s.Pos.ByteSize()
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.IsAwake
		// type: bool
		if s.IsAwake {
			size += 1 + 1
		}

		// property: s.Hp
		// type: float32
		if s.Hp != 0 {
			size += 1 + 4
		}

		// property: s.Poss
		// type: map[int32]*Vector2
		if len(s.Poss) > 0 {
			for k, v := range s.Poss {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: *Vector2
				if v != nil {
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Posi
		// type: map[int32]float32
		if len(s.Posi) > 0 {
			for k, v := range s.Posi {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: float32
				if v != 0 {
					tmp += 1 + 4
				}
				size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Posl
		// type: []*Vector2
		if len(s.Posl) > 0 {
			for _, e := range s.Posl {
				// list element
				// type: *Vector2
				if e != nil {
					tmp := e.ByteSize()
					size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
				} else {
					log.Printf("[Tygo][ByteSize] Nil in a list is treated as an empty object contents default properties!")
					size += 1 + 1
				}
			}
		}

		// property: s.Posll
		// type: [][]*Vector2
		if len(s.Posll) > 0 {
			for _, e := range s.Posll {
				tmp := 0
				// list element
				// type: []*Vector2
				if len(e) > 0 {
					for _, e := range e {
						// list element
						// type: *Vector2
						if e != nil {
							tmpp := e.ByteSize()
							tmp += tygo.SizeVarint(uint64(tmpp)) + tmpp
						} else {
							log.Printf("[Tygo][ByteSize] Nil in a list is treated as an empty object contents default properties!")
							tmp += 1
						}
					}
				}
				size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Pyl
		// type: []*GoType
		if len(s.Pyl) > 0 {
			for _, e := range s.Pyl {
				// list element
				// type: *GoType
				if e != nil {
					tmp := e.ByteSize()
					size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
				} else {
					log.Printf("[Tygo][ByteSize] Nil in a list is treated as an empty object contents default properties!")
					size += 1 + 1
				}
			}
		}

		// property: s.Pyd
		// type: map[int32]*GoType
		if len(s.Pyd) > 0 {
			for k, v := range s.Pyd {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: *GoType
				if v != nil {
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Pyv1
		// type: variant<int32, *GoType>
		if s.Pyv1 != nil {
			tmp := 0
			switch v := s.Pyv1.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: *GoType
			case *GoType:
				// type: *GoType
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, *GoType>: %v", v))
			}
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Pyv2
		// type: variant<int32, *GoType>
		if s.Pyv2 != nil {
			tmp := 0
			switch v := s.Pyv2.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: *GoType
			case *GoType:
				// type: *GoType
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, *GoType>: %v", v))
			}
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

	}
	s.SetCachedSize(size)
	return
}

func (s *Fighter_Part1) Serialize(output *tygo.ProtoBuf) {
	if s != nil {
		// property: s.Pos
		// type: *Vector2
		if s.Pos != nil {
			output.WriteBytes(10) // tag: 10 MAKE_TAG(1, WireBytes=2)
			output.WriteVarint(uint64(s.Pos.CachedSize()))
			s.Pos.Serialize(output)
		}

		// property: s.IsAwake
		// type: bool
		if s.IsAwake {
			output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
			output.WriteBytes(1)
		}

		// property: s.Hp
		// type: float32
		if s.Hp != 0 {
			output.WriteBytes(29) // tag: 29 MAKE_TAG(3, WireFixed32=5)
			output.WriteFixed32(math.Float32bits(s.Hp))
		}

		// property: s.Poss
		// type: map[int32]*Vector2
		if len(s.Poss) > 0 {
			for k, v := range s.Poss {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: *Vector2
				if v != nil {
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: *Vector2
				if v != nil {
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			}
		}

		// property: s.Posi
		// type: map[int32]float32
		if len(s.Posi) > 0 {
			for k, v := range s.Posi {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: float32
				if v != 0 {
					tmp += 1 + 4
				}
				output.WriteBytes(42) // tag: 42 MAKE_TAG(5, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: float32
				if v != 0 {
					output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
					output.WriteFixed32(math.Float32bits(v))
				}
			}
		}

		// property: s.Posl
		// type: []*Vector2
		if len(s.Posl) > 0 {
			for _, e := range s.Posl {
				// list element
				output.WriteBytes(50) // tag: 50 MAKE_TAG(6, WireBytes=2)
				// type: *Vector2
				if e != nil {
					output.WriteVarint(uint64(e.CachedSize()))
					e.Serialize(output)
				} else {
					log.Printf("[Tygo][Serialize] Nil in a list is treated as an empty object contents default properties!")
					output.WriteBytes(0)
				}
			}
		}

		// property: s.Posll
		// type: [][]*Vector2
		if len(s.Posll) > 0 {
			for _, e := range s.Posll {
				tmp := 0
				// list element size
				// type: []*Vector2
				if len(e) > 0 {
					for _, e := range e {
						// list element
						// type: *Vector2
						if e != nil {
							tmpp := e.CachedSize()
							tmp += tygo.SizeVarint(uint64(tmpp)) + tmpp
						} else {
							log.Printf("[Tygo][ByteSize] Nil in a list is treated as an empty object contents default properties!")
							tmp += 1
						}
					}
				}
				output.WriteBytes(58) // tag: 58 MAKE_TAG(7, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// list element serialize
				// type: []*Vector2
				if len(e) > 0 {
					for _, e := range e {
						// list element
						// type: *Vector2
						if e != nil {
							output.WriteVarint(uint64(e.CachedSize()))
							e.Serialize(output)
						} else {
							log.Printf("[Tygo][Serialize] Nil in a list is treated as an empty object contents default properties!")
							output.WriteBytes(0)
						}
					}
				}
			}
		}

		// property: s.Pyl
		// type: []*GoType
		if len(s.Pyl) > 0 {
			for _, e := range s.Pyl {
				// list element
				output.WriteBytes(66) // tag: 66 MAKE_TAG(8, WireBytes=2)
				// type: *GoType
				if e != nil {
					output.WriteVarint(uint64(e.CachedSize()))
					e.Serialize(output)
				} else {
					log.Printf("[Tygo][Serialize] Nil in a list is treated as an empty object contents default properties!")
					output.WriteBytes(0)
				}
			}
		}

		// property: s.Pyd
		// type: map[int32]*GoType
		if len(s.Pyd) > 0 {
			for k, v := range s.Pyd {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: *GoType
				if v != nil {
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				output.WriteBytes(74) // tag: 74 MAKE_TAG(9, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: *GoType
				if v != nil {
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			}
		}

		// property: s.Pyv1
		// type: variant<int32, *GoType>
		if s.Pyv1 != nil {
			tmp := 0
			switch v := s.Pyv1.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: *GoType
			case *GoType:
				// type: *GoType
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, *GoType>: %v", v))
			}
			output.WriteBytes(82) // tag: 82 MAKE_TAG(10, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Pyv1.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: *GoType
			case *GoType:
				// type: *GoType
				{
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, *GoType>: %v", v))
			}
		}

		// property: s.Pyv2
		// type: variant<int32, *GoType>
		if s.Pyv2 != nil {
			tmp := 0
			switch v := s.Pyv2.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: *GoType
			case *GoType:
				// type: *GoType
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, *GoType>: %v", v))
			}
			output.WriteBytes(90) // tag: 90 MAKE_TAG(11, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Pyv2.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: *GoType
			case *GoType:
				// type: *GoType
				{
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, *GoType>: %v", v))
			}
		}

	}
}

func (s *Fighter_Part1) Deserialize(input *tygo.ProtoBuf) (err error) {
object_tmp_2:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(127); err != nil {
			return
		} else if cutoff {
		switch_tmp_2:
			switch tag >> 3 {
			// property: s.Pos
			case 1:
				if tag == 10 { // MAKE_TAG(1, WireBytes=2)
					// type: *Vector2
					if x, e := input.ReadBuf(); e == nil {
						if s.Pos == nil {
							s.Pos = &Vector2{}
						}
						if len(x) > 0 {
							if err = s.Pos.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(16) { // tag: 16 MAKE_TAG(2, WireVarint=0)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 16 // MAKE_TAG(2, WireVarint=0) // fallthrough case 2
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.IsAwake
			case 2:
				if tag == 16 { // MAKE_TAG(2, WireVarint=0)
					// type: bool
					if x, e := input.ReadByte(); e == nil {
						s.IsAwake = x != 0
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(29) { // tag: 29 MAKE_TAG(3, WireFixed32=5)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 29 // MAKE_TAG(3, WireFixed32=5) // fallthrough case 3
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Hp
			case 3:
				if tag == 29 { // MAKE_TAG(3, WireFixed32=5)
					// type: float32
					if x, e := input.ReadFixed32(); e == nil {
						s.Hp = math.Float32frombits(x)
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(34) { // tag: 34 MAKE_TAG(4, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 34 // MAKE_TAG(4, WireBytes=2) // fallthrough case 4
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Poss
			case 4:
				if tag == 34 { // MAKE_TAG(4, WireBytes=2)
				loop_tmp_3:
					// type: map[int32]*Vector2
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Poss == nil {
								s.Poss = make(map[int32]*Vector2)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_3 int32
							var tmp_4 *Vector2
						dict_tmp_3:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_3:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_3 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_3 // next tag for map[int32]*Vector2
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_3 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: *Vector2
											if x, e := tmpi.ReadBuf(); e == nil {
												if tmp_4 == nil {
													tmp_4 = &Vector2{}
												}
												if len(x) > 0 {
													if err = tmp_4.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_3 // end for map[int32]*Vector2
											}
											continue dict_tmp_3 // next tag for map[int32]*Vector2
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Poss[tmp_3] = tmp_4
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(34) { // tag: 34 MAKE_TAG(4, WireBytes=2)
							break loop_tmp_3 // end for map[int32]*Vector2
						}
					}
					if !input.ExpectBytes(42) { // tag: 42 MAKE_TAG(5, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 42 // MAKE_TAG(5, WireBytes=2) // fallthrough case 5
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Posi
			case 5:
				if tag == 42 { // MAKE_TAG(5, WireBytes=2)
				loop_tmp_5:
					// type: map[int32]float32
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Posi == nil {
								s.Posi = make(map[int32]float32)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_5 int32
							var tmp_6 float32
						dict_tmp_5:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_5:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_5 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(21) { // tag: 21 MAKE_TAG(2, WireFixed32=5)
												continue dict_tmp_5 // next tag for map[int32]float32
											}
											tmpg = 21 // fallthrough case 2
										} else {
											break switch_tmp_5 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
											// type: float32
											if x, e := tmpi.ReadFixed32(); e == nil {
												tmp_6 = math.Float32frombits(x)
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_5 // end for map[int32]float32
											}
											continue dict_tmp_5 // next tag for map[int32]float32
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Posi[tmp_5] = tmp_6
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(42) { // tag: 42 MAKE_TAG(5, WireBytes=2)
							break loop_tmp_5 // end for map[int32]float32
						}
					}
					if !input.ExpectBytes(50) { // tag: 50 MAKE_TAG(6, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 50 // MAKE_TAG(6, WireBytes=2) // fallthrough case 6
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Posl
			case 6:
				if tag == 50 { // MAKE_TAG(6, WireBytes=2)
				loop_tmp_7:
					// type: []*Vector2
					for {
						var tmp_7 *Vector2
						// type: *Vector2
						if x, e := input.ReadBuf(); e == nil {
							if tmp_7 == nil {
								tmp_7 = &Vector2{}
							}
							if len(x) > 0 {
								if err = tmp_7.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
									return
								}
							}
						} else {
							err = e
							return
						}
						s.Posl = append(s.Posl, tmp_7)
						if !input.ExpectBytes(50) { // tag: 50 MAKE_TAG(6, WireBytes=2)
							break loop_tmp_7 // end for []*Vector2
						}
					}
					if !input.ExpectBytes(58) { // tag: 58 MAKE_TAG(7, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 58 // MAKE_TAG(7, WireBytes=2) // fallthrough case 7
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Posll
			case 7:
				if tag == 58 { // MAKE_TAG(7, WireBytes=2)
				loop_tmp_8:
					// type: [][]*Vector2
					for {
						if x, e := input.ReadBuf(); e == nil {
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_8 []*Vector2
							for !tmpi.ExpectEnd() {
								// type: []*Vector2
								var tmp_9 *Vector2
								// type: *Vector2
								if x, e := tmpi.ReadBuf(); e == nil {
									if tmp_9 == nil {
										tmp_9 = &Vector2{}
									}
									if len(x) > 0 {
										if err = tmp_9.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
											return
										}
									}
								} else {
									err = e
									return
								}
								tmp_8 = append(tmp_8, tmp_9)
							}
							s.Posll = append(s.Posll, tmp_8)
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(58) { // tag: 58 MAKE_TAG(7, WireBytes=2)
							break loop_tmp_8 // end for [][]*Vector2
						}
					}
					if !input.ExpectBytes(66) { // tag: 66 MAKE_TAG(8, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 66 // MAKE_TAG(8, WireBytes=2) // fallthrough case 8
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Pyl
			case 8:
				if tag == 66 { // MAKE_TAG(8, WireBytes=2)
				loop_tmp_10:
					// type: []*GoType
					for {
						var tmp_10 *GoType
						// type: *GoType
						if x, e := input.ReadBuf(); e == nil {
							if tmp_10 == nil {
								tmp_10 = &GoType{}
							}
							if len(x) > 0 {
								if err = tmp_10.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
									return
								}
							}
						} else {
							err = e
							return
						}
						s.Pyl = append(s.Pyl, tmp_10)
						if !input.ExpectBytes(66) { // tag: 66 MAKE_TAG(8, WireBytes=2)
							break loop_tmp_10 // end for []*GoType
						}
					}
					if !input.ExpectBytes(74) { // tag: 74 MAKE_TAG(9, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 74 // MAKE_TAG(9, WireBytes=2) // fallthrough case 9
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Pyd
			case 9:
				if tag == 74 { // MAKE_TAG(9, WireBytes=2)
				loop_tmp_11:
					// type: map[int32]*GoType
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Pyd == nil {
								s.Pyd = make(map[int32]*GoType)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_11 int32
							var tmp_12 *GoType
						dict_tmp_11:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_11:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_11 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_11 // next tag for map[int32]*GoType
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_11 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: *GoType
											if x, e := tmpi.ReadBuf(); e == nil {
												if tmp_12 == nil {
													tmp_12 = &GoType{}
												}
												if len(x) > 0 {
													if err = tmp_12.Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_11 // end for map[int32]*GoType
											}
											continue dict_tmp_11 // next tag for map[int32]*GoType
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Pyd[tmp_11] = tmp_12
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(74) { // tag: 74 MAKE_TAG(9, WireBytes=2)
							break loop_tmp_11 // end for map[int32]*GoType
						}
					}
					if !input.ExpectBytes(82) { // tag: 82 MAKE_TAG(10, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 82 // MAKE_TAG(10, WireBytes=2) // fallthrough case 10
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Pyv1
			case 10:
				if tag == 82 { // MAKE_TAG(10, WireBytes=2)
					// type: variant<int32, *GoType>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_13:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Pyv1 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_13 // next tag for variant<int32, *GoType>
									}
								case 2:
									if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
										// type: *GoType
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.Pyv1 == nil {
												s.Pyv1 = &GoType{}
											}
											if len(x) > 0 {
												if err = s.Pyv1.(*GoType).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_13 // next tag for variant<int32, *GoType>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(90) { // tag: 90 MAKE_TAG(11, WireBytes=2)
						continue object_tmp_2 // next tag for Fighter_Part1
					}
					tag = 90 // MAKE_TAG(11, WireBytes=2) // fallthrough case 11
				} else {
					break switch_tmp_2 // skip tag
				}
				fallthrough
			// property: s.Pyv2
			case 11:
				if tag == 90 { // MAKE_TAG(11, WireBytes=2)
					// type: variant<int32, *GoType>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_14:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Pyv2 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_14 // next tag for variant<int32, *GoType>
									}
								case 2:
									if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
										// type: *GoType
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.Pyv2 == nil {
												s.Pyv2 = &GoType{}
											}
											if len(x) > 0 {
												if err = s.Pyv2.(*GoType).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_14 // next tag for variant<int32, *GoType>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if input.ExpectEnd() {
						break object_tmp_2 // end for Fighter_Part1
					}
					continue object_tmp_2 // next tag for Fighter_Part1
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

type Fighter_Part2 struct {
	Fighter_Part1
	Fl []float32         // []float32
	Bl [][]byte          // []bytes
	Sl []string          // []string
	Bd map[string][]byte // map[string]bytes
	Sd map[int32]string  // map[int32]string
	El []Corpus          // []Corpus
	Ed map[int32]Corpus  // map[int32]Corpus
	Ll [][]float32       // [][]float32
}

func (s *Fighter_Part2) MaxFieldNum() int {
	return 19
}

func (s *Fighter_Part2) ByteSize() (size int) {
	if s != nil {
		size += s.Fighter_Part1.ByteSize()
		// property: s.Fl
		// type: []float32
		if len(s.Fl) > 0 {
			tmp := len(s.Fl) * 4
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Bl
		// type: []bytes
		if len(s.Bl) > 0 {
			for _, e := range s.Bl {
				// list element
				// type: bytes
				if len(e) > 0 {
					l := len([]byte(e))
					size += 1 + tygo.SizeVarint(uint64(l)) + l
				} else {
					log.Printf("[Tygo][ByteSize] Nil in a list is treated as an empty object contents default properties!")
					size += 1 + 1
				}
			}
		}

		// property: s.Sl
		// type: []string
		if len(s.Sl) > 0 {
			for _, e := range s.Sl {
				// list element
				// type: string
				if len(e) > 0 {
					l := len([]byte(e))
					size += 1 + tygo.SizeVarint(uint64(l)) + l
				} else {
					log.Printf("[Tygo][ByteSize] Nil in a list is treated as an empty object contents default properties!")
					size += 1 + 1
				}
			}
		}

		// property: s.Bd
		// type: map[string]bytes
		if len(s.Bd) > 0 {
			for k, v := range s.Bd {
				tmp := 0
				// dict key
				// type: string
				if len(k) > 0 {
					l := len([]byte(k))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
				// dict value
				// type: bytes
				if len(v) > 0 {
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
				size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Sd
		// type: map[int32]string
		if len(s.Sd) > 0 {
			for k, v := range s.Sd {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: string
				if len(v) > 0 {
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.El
		// type: []Corpus
		if len(s.El) > 0 {
			tmp := 0
			for _, e := range s.El {
				// list element
				// type: Corpus
				tmp += tygo.SizeVarint(uint64(e))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Ed
		// type: map[int32]Corpus
		if len(s.Ed) > 0 {
			for k, v := range s.Ed {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: Corpus
				if v != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(v))
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Ll
		// type: [][]float32
		if len(s.Ll) > 0 {
			for _, e := range s.Ll {
				// list element
				// type: []float32
				if len(e) > 0 {
					tmp := len(e) * 4
					size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
				} else {
					size += 2 + 1
				}
			}
		}

	}
	s.SetCachedSize(size)
	return
}

func (s *Fighter_Part2) Serialize(output *tygo.ProtoBuf) {
	if s != nil {
		s.Fighter_Part1.Serialize(output)
		// property: s.Fl
		// type: []float32
		if len(s.Fl) > 0 {
			tmp := len(s.Fl) * 4
			output.WriteBytes(98) // tag: 98 MAKE_TAG(12, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			for _, e := range s.Fl {
				// list element serialize
				// type: float32
				output.WriteFixed32(math.Float32bits(e))
			}
		}

		// property: s.Bl
		// type: []bytes
		if len(s.Bl) > 0 {
			for _, e := range s.Bl {
				// list element
				output.WriteBytes(106) // tag: 106 MAKE_TAG(13, WireBytes=2)
				// type: bytes
				if len(e) > 0 {
					output.WriteBuf([]byte(e))
				} else {
					log.Printf("[Tygo][Serialize] Nil in a list is treated as an empty object contents default properties!")
					output.WriteBytes(0)
				}
			}
		}

		// property: s.Sl
		// type: []string
		if len(s.Sl) > 0 {
			for _, e := range s.Sl {
				// list element
				output.WriteBytes(114) // tag: 114 MAKE_TAG(14, WireBytes=2)
				// type: string
				if len(e) > 0 {
					output.WriteBuf([]byte(e))
				} else {
					log.Printf("[Tygo][Serialize] Nil in a list is treated as an empty object contents default properties!")
					output.WriteBytes(0)
				}
			}
		}

		// property: s.Bd
		// type: map[string]bytes
		if len(s.Bd) > 0 {
			for k, v := range s.Bd {
				tmp := 0
				// dict key size
				// type: string
				if len(k) > 0 {
					l := len([]byte(k))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
				// dict value size
				// type: bytes
				if len(v) > 0 {
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
				output.WriteBytes(122) // tag: 122 MAKE_TAG(15, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: string
				if len(k) > 0 {
					output.WriteBytes(10) // tag: 10 MAKE_TAG(1, WireBytes=2)
					output.WriteBuf([]byte(k))
				}
				// dict value serialize
				// type: bytes
				if len(v) > 0 {
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			}
		}

		// property: s.Sd
		// type: map[int32]string
		if len(s.Sd) > 0 {
			for k, v := range s.Sd {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: string
				if len(v) > 0 {
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
				output.WriteBytes(130, 1) // tag: 130 MAKE_TAG(16, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: string
				if len(v) > 0 {
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			}
		}

		// property: s.El
		// type: []Corpus
		if len(s.El) > 0 {
			tmp := 0
			for _, e := range s.El {
				// list element size
				// type: Corpus
				tmp += tygo.SizeVarint(uint64(e))
			}
			output.WriteBytes(138, 1) // tag: 138 MAKE_TAG(17, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			for _, e := range s.El {
				// list element serialize
				// type: Corpus
				output.WriteVarint(uint64(e))
			}
		}

		// property: s.Ed
		// type: map[int32]Corpus
		if len(s.Ed) > 0 {
			for k, v := range s.Ed {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: Corpus
				if v != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(v))
				}
				output.WriteBytes(146, 1) // tag: 146 MAKE_TAG(18, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: Corpus
				if v != 0 {
					output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
					output.WriteVarint(uint64(v))
				}
			}
		}

		// property: s.Ll
		// type: [][]float32
		if len(s.Ll) > 0 {
			for _, e := range s.Ll {
				// list element
				// type: []float32
				if len(e) > 0 {
					tmp := len(e) * 4
					output.WriteBytes(154, 1) // tag: 154 MAKE_TAG(19, WireBytes=2)
					output.WriteVarint(uint64(tmp))
					for _, e := range e {
						// list element serialize
						// type: float32
						output.WriteFixed32(math.Float32bits(e))
					}
				} else {
					output.WriteBytes(154, 1) // tag: 154 MAKE_TAG(19, WireBytes=2)
					output.WriteBytes(0)
				}
			}
		}

	}
}

func (s *Fighter_Part2) Deserialize(input *tygo.ProtoBuf) (err error) {
	if err = s.Fighter_Part1.Deserialize(input); err == nil {
		input.Reset()
	} else {
		return
	}
object_tmp_15:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(1023); err != nil {
			return
		} else if cutoff {
		switch_tmp_15:
			switch (tag >> 3) - 11 {
			// property: s.Fl
			case 1:
				if tag == 101 || tag == 98 { // MAKE_TAG(12, WireFixed32=5) || MAKE_TAG(12, WireBytes=2)
					// type: []float32
					if tag == 101 { // MAKE_TAG(12, WireFixed32=5)
					loop_tmp_16:
						for {
							var tmp_16 float32
							// type: float32
							if x, e := input.ReadFixed32(); e == nil {
								tmp_16 = math.Float32frombits(x)
							} else {
								err = e
								return
							}
							s.Fl = append(s.Fl, tmp_16)
							if !input.ExpectBytes(101) { // tag: 101 MAKE_TAG(12, WireFixed32=5)
								break loop_tmp_16 // end for []float32
							}
						}
					} else if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
						for !tmpi.ExpectEnd() {
							var tmp_16 float32
							// type: float32
							if x, e := tmpi.ReadFixed32(); e == nil {
								tmp_16 = math.Float32frombits(x)
							} else {
								err = e
								return
							}
							s.Fl = append(s.Fl, tmp_16)
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(106) { // tag: 106 MAKE_TAG(13, WireBytes=2)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 106 // MAKE_TAG(13, WireBytes=2) // fallthrough case 2
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.Bl
			case 2:
				if tag == 106 { // MAKE_TAG(13, WireBytes=2)
				loop_tmp_17:
					// type: []bytes
					for {
						var tmp_17 []byte
						// type: bytes
						if x, e := input.ReadBuf(); e == nil {
							tmp_17 = make([]byte, len(x))
							copy(tmp_17, x)
						} else {
							err = e
							return
						}
						s.Bl = append(s.Bl, tmp_17)
						if !input.ExpectBytes(106) { // tag: 106 MAKE_TAG(13, WireBytes=2)
							break loop_tmp_17 // end for []bytes
						}
					}
					if !input.ExpectBytes(114) { // tag: 114 MAKE_TAG(14, WireBytes=2)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 114 // MAKE_TAG(14, WireBytes=2) // fallthrough case 3
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.Sl
			case 3:
				if tag == 114 { // MAKE_TAG(14, WireBytes=2)
				loop_tmp_18:
					// type: []string
					for {
						var tmp_18 string
						// type: string
						if x, e := input.ReadBuf(); e == nil {
							tmp_18 = string(x)
						} else {
							err = e
							return
						}
						s.Sl = append(s.Sl, tmp_18)
						if !input.ExpectBytes(114) { // tag: 114 MAKE_TAG(14, WireBytes=2)
							break loop_tmp_18 // end for []string
						}
					}
					if !input.ExpectBytes(122) { // tag: 122 MAKE_TAG(15, WireBytes=2)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 122 // MAKE_TAG(15, WireBytes=2) // fallthrough case 4
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.Bd
			case 4:
				if tag == 122 { // MAKE_TAG(15, WireBytes=2)
				loop_tmp_19:
					// type: map[string]bytes
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Bd == nil {
								s.Bd = make(map[string][]byte)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_19 string
							var tmp_20 []byte
						dict_tmp_19:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_19:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 10 { // MAKE_TAG(1, WireBytes=2)
											// type: string
											if x, e := tmpi.ReadBuf(); e == nil {
												tmp_19 = string(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_19 // next tag for map[string]bytes
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_19 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: bytes
											if x, e := tmpi.ReadBuf(); e == nil {
												tmp_20 = make([]byte, len(x))
												copy(tmp_20, x)
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_19 // end for map[string]bytes
											}
											continue dict_tmp_19 // next tag for map[string]bytes
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Bd[tmp_19] = tmp_20
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(122) { // tag: 122 MAKE_TAG(15, WireBytes=2)
							break loop_tmp_19 // end for map[string]bytes
						}
					}
					if !input.ExpectBytes(130, 1) { // tag: 130 MAKE_TAG(16, WireBytes=2)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 130 // MAKE_TAG(16, WireBytes=2) // fallthrough case 5
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.Sd
			case 5:
				if tag == 130 { // MAKE_TAG(16, WireBytes=2)
				loop_tmp_21:
					// type: map[int32]string
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Sd == nil {
								s.Sd = make(map[int32]string)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_21 int32
							var tmp_22 string
						dict_tmp_21:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_21:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_21 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_21 // next tag for map[int32]string
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_21 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: string
											if x, e := tmpi.ReadBuf(); e == nil {
												tmp_22 = string(x)
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_21 // end for map[int32]string
											}
											continue dict_tmp_21 // next tag for map[int32]string
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Sd[tmp_21] = tmp_22
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(130, 1) { // tag: 130 MAKE_TAG(16, WireBytes=2)
							break loop_tmp_21 // end for map[int32]string
						}
					}
					if !input.ExpectBytes(136, 1) { // tag: 136 MAKE_TAG(17, WireVarint=0)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 136 // MAKE_TAG(17, WireVarint=0) // fallthrough case 6
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.El
			case 6:
				if tag == 136 || tag == 138 { // MAKE_TAG(17, WireVarint=0) || MAKE_TAG(17, WireBytes=2)
					// type: []Corpus
					if tag == 136 { // MAKE_TAG(17, WireVarint=0)
					loop_tmp_23:
						for {
							var tmp_23 Corpus
							// type: Corpus
							if x, e := input.ReadVarint(); e == nil {
								tmp_23 = Corpus(x)
							} else {
								err = e
								return
							}
							s.El = append(s.El, tmp_23)
							if !input.ExpectBytes(136, 1) { // tag: 136 MAKE_TAG(17, WireVarint=0)
								break loop_tmp_23 // end for []Corpus
							}
						}
					} else if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
						for !tmpi.ExpectEnd() {
							var tmp_23 Corpus
							// type: Corpus
							if x, e := tmpi.ReadVarint(); e == nil {
								tmp_23 = Corpus(x)
							} else {
								err = e
								return
							}
							s.El = append(s.El, tmp_23)
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(146, 1) { // tag: 146 MAKE_TAG(18, WireBytes=2)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 146 // MAKE_TAG(18, WireBytes=2) // fallthrough case 7
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.Ed
			case 7:
				if tag == 146 { // MAKE_TAG(18, WireBytes=2)
				loop_tmp_24:
					// type: map[int32]Corpus
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Ed == nil {
								s.Ed = make(map[int32]Corpus)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_24 int32
							var tmp_25 Corpus
						dict_tmp_24:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_24:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_24 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(16) { // tag: 16 MAKE_TAG(2, WireVarint=0)
												continue dict_tmp_24 // next tag for map[int32]Corpus
											}
											tmpg = 16 // fallthrough case 2
										} else {
											break switch_tmp_24 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 16 { // MAKE_TAG(2, WireVarint=0)
											// type: Corpus
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_25 = Corpus(x)
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_24 // end for map[int32]Corpus
											}
											continue dict_tmp_24 // next tag for map[int32]Corpus
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Ed[tmp_24] = tmp_25
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(146, 1) { // tag: 146 MAKE_TAG(18, WireBytes=2)
							break loop_tmp_24 // end for map[int32]Corpus
						}
					}
					if !input.ExpectBytes(154, 1) { // tag: 154 MAKE_TAG(19, WireBytes=2)
						continue object_tmp_15 // next tag for Fighter_Part2
					}
					tag = 154 // MAKE_TAG(19, WireBytes=2) // fallthrough case 8
				} else {
					break switch_tmp_15 // skip tag
				}
				fallthrough
			// property: s.Ll
			case 8:
				if tag == 154 { // MAKE_TAG(19, WireBytes=2)
				loop_tmp_26:
					// type: [][]float32
					for {
						var tmp_26 []float32
						// type: []float32
						if x, e := input.ReadBuf(); e == nil {
							tmpi := &tygo.ProtoBuf{Buffer: x}
							for !tmpi.ExpectEnd() {
								var tmp_27 float32
								// type: float32
								if x, e := tmpi.ReadFixed32(); e == nil {
									tmp_27 = math.Float32frombits(x)
								} else {
									err = e
									return
								}
								tmp_26 = append(tmp_26, tmp_27)
							}
						} else {
							err = e
							return
						}
						s.Ll = append(s.Ll, tmp_26)
						if !input.ExpectBytes(157, 1) { // tag: 157 MAKE_TAG(19, WireFixed32=5)
							break loop_tmp_26 // end for [][]float32
						}
					}
					if input.ExpectEnd() {
						break object_tmp_15 // end for Fighter_Part2
					}
					continue object_tmp_15 // next tag for Fighter_Part2
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

type Fighter struct {
	Fighter_Part2
	V0  interface{}                     // variant<int32, float32, bytes, *Vector2>
	V1  interface{}                     // variant<int32, float32, bytes, *Vector2>
	V2  interface{}                     // variant<int32, float32, bytes, *Vector2>
	V3  interface{}                     // variant<int32, float32, bytes, *Vector2>
	V4  interface{}                     // variant<int32, float32, bytes, *Vector2>
	Vl  []interface{}                   // []variant<int32, fixedpoint<3, 0>, string, *Vector2>
	Vd  map[int32]interface{}           // map[int32]variant<Corpus, float64, string, *Vector2>
	Ld  map[int32][]interface{}         // map[int32][]variant<Corpus, float64, string, *Vector2>
	Fld map[int32][]float32             // map[int32][]float32
	Dd  map[int32]map[int32]interface{} // map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
	Fdd map[int32]map[int32]float32     // map[int32]map[int32]float32
	Nv  interface{}                     // variant<nil, int32>
	Lv  interface{}                     // variant<int32, []variant<float32, string>>
	Flv interface{}                     // variant<int32, []float32>
	Dv  interface{}                     // variant<int32, map[int32]variant<float32, string>>
	Fdv interface{}                     // variant<int32, map[int32]float32>
}

func (s *Fighter) MaxFieldNum() int {
	return 35
}

func (s *Fighter) ByteSize() (size int) {
	if s != nil {
		size += s.Fighter_Part2.ByteSize()
		// property: s.V0
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V0 != nil {
			tmp := 0
			switch v := s.V0.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.V1
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V1 != nil {
			tmp := 0
			switch v := s.V1.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.V2
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V2 != nil {
			tmp := 0
			switch v := s.V2.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.V3
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V3 != nil {
			tmp := 0
			switch v := s.V3.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.V4
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V4 != nil {
			tmp := 0
			switch v := s.V4.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.ByteSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Vl
		// type: []variant<int32, fixedpoint<3, 0>, string, *Vector2>
		if len(s.Vl) > 0 {
			for _, e := range s.Vl {
				// list element
				// type: variant<int32, fixedpoint<3, 0>, string, *Vector2>
				if e != nil {
					tmp := 0
					switch v := e.(type) {
					// variant type: int32
					case int32:
						// type: int32
						tmp += 1 + tygo.SizeVarint(uint64(v))
					// variant type: fixedpoint<3, 0>
					case float64:
						// type: fixedpoint<3, 0>
						tmp += 1 + tygo.SizeVarint(uint64(v * 1000))
					// variant type: string
					case string:
						// type: string
						{
							l := len([]byte(v))
							tmp += 1 + tygo.SizeVarint(uint64(l)) + l
						}
					// variant type: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							tmpp := v.ByteSize()
							tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
						}
					// addition type: int
					case int:
						tmp += 1 + tygo.SizeVarint(uint64(v))
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, fixedpoint<3, 0>, string, *Vector2>: %v", v))
					}
					size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
				} else {
					size += 2 + 1
				}
			}
		}

		// property: s.Vd
		// type: map[int32]variant<Corpus, float64, string, *Vector2>
		if len(s.Vd) > 0 {
			for k, v := range s.Vd {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: variant<Corpus, float64, string, *Vector2>
				if v != nil {
					tmpp := 0
					switch v := v.(type) {
					// variant type: Corpus
					case Corpus:
						// type: Corpus
						tmpp += 1 + tygo.SizeVarint(uint64(v))
					// variant type: float64
					case float64:
						// type: float64
						tmpp += 1 + 8
					// variant type: string
					case string:
						// type: string
						{
							l := len([]byte(v))
							tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
						}
					// variant type: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							tmppp := v.ByteSize()
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
					// addition type: int -> float64
					case int:
						tmpp += 9
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
					}
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Ld
		// type: map[int32][]variant<Corpus, float64, string, *Vector2>
		if len(s.Ld) > 0 {
			for k, v := range s.Ld {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: []variant<Corpus, float64, string, *Vector2>
				if len(v) > 0 {
					for _, e := range v {
						// list element
						// type: variant<Corpus, float64, string, *Vector2>
						if e != nil {
							tmpp := 0
							switch v := e.(type) {
							// variant type: Corpus
							case Corpus:
								// type: Corpus
								tmpp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: float64
							case float64:
								// type: float64
								tmpp += 1 + 8
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmppp := v.ByteSize()
									tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
								}
							// addition type: int -> float64
							case int:
								tmpp += 9
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
							}
							tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
						} else {
							tmp += 1 + 1
						}
					}
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Fld
		// type: map[int32][]float32
		if len(s.Fld) > 0 {
			for k, v := range s.Fld {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: []float32
				if len(v) > 0 {
					tmpp := len(v) * 4
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Dd
		// type: map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
		if len(s.Dd) > 0 {
			for k, v := range s.Dd {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: map[int32]variant<int32, Corpus, float64, string, *Vector2>
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: variant<int32, Corpus, float64, string, *Vector2>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type: int32
							case int32:
								// type: int32
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: Corpus
							case Corpus:
								// type: Corpus
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: float64
							case float64:
								// type: float64
								tmppp += 1 + 8
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmpppp := v.ByteSize()
									tmppp += 1 + tygo.SizeVarint(uint64(tmpppp)) + tmpppp
								}
							// addition type: int
							case int:
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, Corpus, float64, string, *Vector2>: %v", v))
							}
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Fdd
		// type: map[int32]map[int32]float32
		if len(s.Fdd) > 0 {
			for k, v := range s.Fdd {
				tmp := 0
				// dict key
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value
				// type: map[int32]float32
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: float32
						if v != 0 {
							tmpp += 1 + 4
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
				size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
			}
		}

		// property: s.Nv
		// type: variant<nil, int32>
		if s.Nv != nil {
			tmp := 0
			switch v := s.Nv.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Lv
		// type: variant<int32, []variant<float32, string>>
		if s.Lv != nil {
			tmp := 0
			switch v := s.Lv.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: []variant<float32, string>
			case []interface{}:
				// type: []variant<float32, string>
				if len(v) > 0 {
					for _, e := range v {
						// list element
						// type: variant<float32, string>
						if e != nil {
							tmpp := 0
							switch v := e.(type) {
							// variant type: float32
							case float32:
								// type: float32
								tmpp += 1 + 4
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type: int -> float32
							case int:
								tmpp += 5
							// addition type: float64 -> float32
							case float64:
								tmpp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
						} else {
							tmp += 1 + 1
						}
					}
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, []variant<float32, string>>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Flv
		// type: variant<int32, []float32>
		if s.Flv != nil {
			tmp := 0
			switch v := s.Flv.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: []float32
			case []float32:
				// type: []float32
				if len(v) > 0 {
					tmpp := len(v) * 4
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, []float32>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Dv
		// type: variant<int32, map[int32]variant<float32, string>>
		if s.Dv != nil {
			tmp := 0
			switch v := s.Dv.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: map[int32]variant<float32, string>
			case map[int32]interface{}:
				// type: map[int32]variant<float32, string>
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: variant<float32, string>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type: float32
							case float32:
								// type: float32
								tmppp += 1 + 4
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type: int -> float32
							case int:
								tmppp += 5
							// addition type: float64 -> float32
							case float64:
								tmppp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, map[int32]variant<float32, string>>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

		// property: s.Fdv
		// type: variant<int32, map[int32]float32>
		if s.Fdv != nil {
			tmp := 0
			switch v := s.Fdv.(type) {
			// variant type: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type: map[int32]float32
			case map[int32]float32:
				// type: map[int32]float32
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: float32
						if v != 0 {
							tmpp += 1 + 4
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
			// addition type: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, map[int32]float32>: %v", v))
			}
			size += 2 + tygo.SizeVarint(uint64(tmp)) + tmp
		}

	}
	s.SetCachedSize(size)
	return
}

func (s *Fighter) Serialize(output *tygo.ProtoBuf) {
	if s != nil {
		s.Fighter_Part2.Serialize(output)
		// property: s.V0
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V0 != nil {
			tmp := 0
			switch v := s.V0.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type size: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type size: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type size: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			output.WriteBytes(162, 1) // tag: 162 MAKE_TAG(20, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.V0.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: float32
			case float32:
				// type: float32
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(v))
			// variant type serialize: bytes
			case []byte:
				// type: bytes
				{
					output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			// variant type serialize: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// addition type serialize: float64 -> float32
			case float64:
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(float32(v)))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
		}

		// property: s.V1
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V1 != nil {
			tmp := 0
			switch v := s.V1.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type size: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type size: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type size: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			output.WriteBytes(170, 1) // tag: 170 MAKE_TAG(21, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.V1.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: float32
			case float32:
				// type: float32
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(v))
			// variant type serialize: bytes
			case []byte:
				// type: bytes
				{
					output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			// variant type serialize: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// addition type serialize: float64 -> float32
			case float64:
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(float32(v)))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
		}

		// property: s.V2
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V2 != nil {
			tmp := 0
			switch v := s.V2.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type size: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type size: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type size: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			output.WriteBytes(178, 1) // tag: 178 MAKE_TAG(22, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.V2.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: float32
			case float32:
				// type: float32
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(v))
			// variant type serialize: bytes
			case []byte:
				// type: bytes
				{
					output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			// variant type serialize: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// addition type serialize: float64 -> float32
			case float64:
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(float32(v)))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
		}

		// property: s.V3
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V3 != nil {
			tmp := 0
			switch v := s.V3.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type size: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type size: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type size: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			output.WriteBytes(186, 1) // tag: 186 MAKE_TAG(23, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.V3.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: float32
			case float32:
				// type: float32
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(v))
			// variant type serialize: bytes
			case []byte:
				// type: bytes
				{
					output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			// variant type serialize: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// addition type serialize: float64 -> float32
			case float64:
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(float32(v)))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
		}

		// property: s.V4
		// type: variant<int32, float32, bytes, *Vector2>
		if s.V4 != nil {
			tmp := 0
			switch v := s.V4.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: float32
			case float32:
				// type: float32
				tmp += 1 + 4
			// variant type size: bytes
			case []byte:
				// type: bytes
				{
					l := len([]byte(v))
					tmp += 1 + tygo.SizeVarint(uint64(l)) + l
				}
			// variant type size: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					tmpp := v.CachedSize()
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type size: float64 -> float32
			case float64:
				tmp += 5
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
			output.WriteBytes(194, 1) // tag: 194 MAKE_TAG(24, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.V4.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: float32
			case float32:
				// type: float32
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(v))
			// variant type serialize: bytes
			case []byte:
				// type: bytes
				{
					output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
					output.WriteBuf([]byte(v))
				}
			// variant type serialize: *Vector2
			case *Vector2:
				// type: *Vector2
				{
					output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
					output.WriteVarint(uint64(v.CachedSize()))
					v.Serialize(output)
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// addition type serialize: float64 -> float32
			case float64:
				output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
				output.WriteFixed32(math.Float32bits(float32(v)))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, float32, bytes, *Vector2>: %v", v))
			}
		}

		// property: s.Vl
		// type: []variant<int32, fixedpoint<3, 0>, string, *Vector2>
		if len(s.Vl) > 0 {
			for _, e := range s.Vl {
				// list element
				output.WriteBytes(202, 1) // tag: 202 MAKE_TAG(25, WireBytes=2)
				// type: variant<int32, fixedpoint<3, 0>, string, *Vector2>
				if e != nil {
					tmp := 0
					switch v := e.(type) {
					// variant type size: int32
					case int32:
						// type: int32
						tmp += 1 + tygo.SizeVarint(uint64(v))
					// variant type size: fixedpoint<3, 0>
					case float64:
						// type: fixedpoint<3, 0>
						tmp += 1 + tygo.SizeVarint(uint64(v * 1000))
					// variant type size: string
					case string:
						// type: string
						{
							l := len([]byte(v))
							tmp += 1 + tygo.SizeVarint(uint64(l)) + l
						}
					// variant type size: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							tmpp := v.CachedSize()
							tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
						}
					// addition type size: int
					case int:
						tmp += 1 + tygo.SizeVarint(uint64(v))
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, fixedpoint<3, 0>, string, *Vector2>: %v", v))
					}
					output.WriteVarint(uint64(tmp))
					switch v := e.(type) {
					// variant type serialize: int32
					case int32:
						// type: int32
						output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
						output.WriteVarint(uint64(v))
					// variant type serialize: fixedpoint<3, 0>
					case float64:
						// type: fixedpoint<3, 0>
						output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
						output.WriteVarint(uint64(v * 1000))
					// variant type serialize: string
					case string:
						// type: string
						{
							output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
							output.WriteBuf([]byte(v))
						}
					// variant type serialize: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
							output.WriteVarint(uint64(v.CachedSize()))
							v.Serialize(output)
						}
					// addition type serialize: int
					case int:
						output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
						output.WriteVarint(uint64(v))
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, fixedpoint<3, 0>, string, *Vector2>: %v", v))
					}
				} else {
					output.WriteBytes(0)
				}
			}
		}

		// property: s.Vd
		// type: map[int32]variant<Corpus, float64, string, *Vector2>
		if len(s.Vd) > 0 {
			for k, v := range s.Vd {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: variant<Corpus, float64, string, *Vector2>
				if v != nil {
					tmpp := 0
					switch v := v.(type) {
					// variant type: Corpus
					case Corpus:
						// type: Corpus
						tmpp += 1 + tygo.SizeVarint(uint64(v))
					// variant type: float64
					case float64:
						// type: float64
						tmpp += 1 + 8
					// variant type: string
					case string:
						// type: string
						{
							l := len([]byte(v))
							tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
						}
					// variant type: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							tmppp := v.CachedSize()
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
					// addition type: int -> float64
					case int:
						tmpp += 9
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
					}
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				output.WriteBytes(210, 1) // tag: 210 MAKE_TAG(26, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: variant<Corpus, float64, string, *Vector2>
				if v != nil {
					tmpp := 0
					switch v := v.(type) {
					// variant type size: Corpus
					case Corpus:
						// type: Corpus
						tmpp += 1 + tygo.SizeVarint(uint64(v))
					// variant type size: float64
					case float64:
						// type: float64
						tmpp += 1 + 8
					// variant type size: string
					case string:
						// type: string
						{
							l := len([]byte(v))
							tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
						}
					// variant type size: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							tmppp := v.CachedSize()
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
					// addition type size: int -> float64
					case int:
						tmpp += 9
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
					}
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(tmpp))
					switch v := v.(type) {
					// variant type serialize: Corpus
					case Corpus:
						// type: Corpus
						output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
						output.WriteVarint(uint64(v))
					// variant type serialize: float64
					case float64:
						// type: float64
						output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
						output.WriteFixed64(math.Float64bits(v))
					// variant type serialize: string
					case string:
						// type: string
						{
							output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
							output.WriteBuf([]byte(v))
						}
					// variant type serialize: *Vector2
					case *Vector2:
						// type: *Vector2
						{
							output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
							output.WriteVarint(uint64(v.CachedSize()))
							v.Serialize(output)
						}
					// addition type serialize: int -> float64
					case int:
						output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
						output.WriteFixed64(math.Float64bits(float64(v)))
					default:
						panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
					}
				}
			}
		}

		// property: s.Ld
		// type: map[int32][]variant<Corpus, float64, string, *Vector2>
		if len(s.Ld) > 0 {
			for k, v := range s.Ld {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: []variant<Corpus, float64, string, *Vector2>
				if len(v) > 0 {
					for _, e := range v {
						// list element
						// type: variant<Corpus, float64, string, *Vector2>
						if e != nil {
							tmpp := 0
							switch v := e.(type) {
							// variant type: Corpus
							case Corpus:
								// type: Corpus
								tmpp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: float64
							case float64:
								// type: float64
								tmpp += 1 + 8
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmppp := v.CachedSize()
									tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
								}
							// addition type: int -> float64
							case int:
								tmpp += 9
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
							}
							tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
						} else {
							tmp += 1 + 1
						}
					}
				}
				output.WriteBytes(218, 1) // tag: 218 MAKE_TAG(27, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: []variant<Corpus, float64, string, *Vector2>
				if len(v) > 0 {
					for _, e := range v {
						// list element
						output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
						// type: variant<Corpus, float64, string, *Vector2>
						if e != nil {
							tmpp := 0
							switch v := e.(type) {
							// variant type size: Corpus
							case Corpus:
								// type: Corpus
								tmpp += 1 + tygo.SizeVarint(uint64(v))
							// variant type size: float64
							case float64:
								// type: float64
								tmpp += 1 + 8
							// variant type size: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type size: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmppp := v.CachedSize()
									tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
								}
							// addition type size: int -> float64
							case int:
								tmpp += 9
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
							}
							output.WriteVarint(uint64(tmpp))
							switch v := e.(type) {
							// variant type serialize: Corpus
							case Corpus:
								// type: Corpus
								output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
								output.WriteVarint(uint64(v))
							// variant type serialize: float64
							case float64:
								// type: float64
								output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
								output.WriteFixed64(math.Float64bits(v))
							// variant type serialize: string
							case string:
								// type: string
								{
									output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
									output.WriteBuf([]byte(v))
								}
							// variant type serialize: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
									output.WriteVarint(uint64(v.CachedSize()))
									v.Serialize(output)
								}
							// addition type serialize: int -> float64
							case int:
								output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
								output.WriteFixed64(math.Float64bits(float64(v)))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
							}
						} else {
							output.WriteBytes(0)
						}
					}
				}
			}
		}

		// property: s.Fld
		// type: map[int32][]float32
		if len(s.Fld) > 0 {
			for k, v := range s.Fld {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: []float32
				if len(v) > 0 {
					tmpp := len(v) * 4
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
				output.WriteBytes(226, 1) // tag: 226 MAKE_TAG(28, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: []float32
				if len(v) > 0 {
					tmpp := len(v) * 4
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(tmpp))
					for _, e := range v {
						// list element serialize
						// type: float32
						output.WriteFixed32(math.Float32bits(e))
					}
				}
			}
		}

		// property: s.Dd
		// type: map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
		if len(s.Dd) > 0 {
			for k, v := range s.Dd {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: map[int32]variant<int32, Corpus, float64, string, *Vector2>
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: variant<int32, Corpus, float64, string, *Vector2>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type: int32
							case int32:
								// type: int32
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: Corpus
							case Corpus:
								// type: Corpus
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: float64
							case float64:
								// type: float64
								tmppp += 1 + 8
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmpppp := v.CachedSize()
									tmppp += 1 + tygo.SizeVarint(uint64(tmpppp)) + tmpppp
								}
							// addition type: int
							case int:
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, Corpus, float64, string, *Vector2>: %v", v))
							}
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
				output.WriteBytes(234, 1) // tag: 234 MAKE_TAG(29, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: map[int32]variant<int32, Corpus, float64, string, *Vector2>
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key size
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value size
						// type: variant<int32, Corpus, float64, string, *Vector2>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type: int32
							case int32:
								// type: int32
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: Corpus
							case Corpus:
								// type: Corpus
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type: float64
							case float64:
								// type: float64
								tmppp += 1 + 8
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmpppp := v.CachedSize()
									tmppp += 1 + tygo.SizeVarint(uint64(tmpppp)) + tmpppp
								}
							// addition type: int
							case int:
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, Corpus, float64, string, *Vector2>: %v", v))
							}
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
						output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
						output.WriteVarint(uint64(tmpp))
						// dict key serialize
						// type: int32
						if k != 0 {
							output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
							output.WriteVarint(uint64(k))
						}
						// dict value serialize
						// type: variant<int32, Corpus, float64, string, *Vector2>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type size: int32
							case int32:
								// type: int32
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type size: Corpus
							case Corpus:
								// type: Corpus
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							// variant type size: float64
							case float64:
								// type: float64
								tmppp += 1 + 8
							// variant type size: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// variant type size: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									tmpppp := v.CachedSize()
									tmppp += 1 + tygo.SizeVarint(uint64(tmpppp)) + tmpppp
								}
							// addition type size: int
							case int:
								tmppp += 1 + tygo.SizeVarint(uint64(v))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, Corpus, float64, string, *Vector2>: %v", v))
							}
							output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
							output.WriteVarint(uint64(tmppp))
							switch v := v.(type) {
							// variant type serialize: int32
							case int32:
								// type: int32
								output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
								output.WriteVarint(uint64(v))
							// variant type serialize: Corpus
							case Corpus:
								// type: Corpus
								output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
								output.WriteVarint(uint64(v))
							// variant type serialize: float64
							case float64:
								// type: float64
								output.WriteBytes(25) // tag: 25 MAKE_TAG(3, WireFixed64=1)
								output.WriteFixed64(math.Float64bits(v))
							// variant type serialize: string
							case string:
								// type: string
								{
									output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
									output.WriteBuf([]byte(v))
								}
							// variant type serialize: *Vector2
							case *Vector2:
								// type: *Vector2
								{
									output.WriteBytes(42) // tag: 42 MAKE_TAG(5, WireBytes=2)
									output.WriteVarint(uint64(v.CachedSize()))
									v.Serialize(output)
								}
							// addition type serialize: int
							case int:
								output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
								output.WriteVarint(uint64(v))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, Corpus, float64, string, *Vector2>: %v", v))
							}
						}
					}
				}
			}
		}

		// property: s.Fdd
		// type: map[int32]map[int32]float32
		if len(s.Fdd) > 0 {
			for k, v := range s.Fdd {
				tmp := 0
				// dict key size
				// type: int32
				if k != 0 {
					tmp += 1 + tygo.SizeVarint(uint64(k))
				}
				// dict value size
				// type: map[int32]float32
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: float32
						if v != 0 {
							tmpp += 1 + 4
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
				output.WriteBytes(242, 1) // tag: 242 MAKE_TAG(30, WireBytes=2)
				output.WriteVarint(uint64(tmp))
				// dict key serialize
				// type: int32
				if k != 0 {
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(k))
				}
				// dict value serialize
				// type: map[int32]float32
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key size
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value size
						// type: float32
						if v != 0 {
							tmpp += 1 + 4
						}
						output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
						output.WriteVarint(uint64(tmpp))
						// dict key serialize
						// type: int32
						if k != 0 {
							output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
							output.WriteVarint(uint64(k))
						}
						// dict value serialize
						// type: float32
						if v != 0 {
							output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
							output.WriteFixed32(math.Float32bits(v))
						}
					}
				}
			}
		}

		// property: s.Nv
		// type: variant<nil, int32>
		if s.Nv != nil {
			tmp := 0
			switch v := s.Nv.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
			}
			output.WriteBytes(250, 1) // tag: 250 MAKE_TAG(31, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Nv.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
				output.WriteVarint(uint64(v))
			// addition type serialize: int
			case int:
				output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
			}
		}

		// property: s.Lv
		// type: variant<int32, []variant<float32, string>>
		if s.Lv != nil {
			tmp := 0
			switch v := s.Lv.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: []variant<float32, string>
			case []interface{}:
				// type: []variant<float32, string>
				if len(v) > 0 {
					for _, e := range v {
						// list element
						// type: variant<float32, string>
						if e != nil {
							tmpp := 0
							switch v := e.(type) {
							// variant type: float32
							case float32:
								// type: float32
								tmpp += 1 + 4
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type: int -> float32
							case int:
								tmpp += 5
							// addition type: float64 -> float32
							case float64:
								tmpp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
						} else {
							tmp += 1 + 1
						}
					}
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, []variant<float32, string>>: %v", v))
			}
			output.WriteBytes(130, 2) // tag: 258 MAKE_TAG(32, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Lv.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: []variant<float32, string>
			case []interface{}:
				// type: []variant<float32, string>
				if len(v) > 0 {
					for _, e := range v {
						// list element
						output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
						// type: variant<float32, string>
						if e != nil {
							tmpp := 0
							switch v := e.(type) {
							// variant type size: float32
							case float32:
								// type: float32
								tmpp += 1 + 4
							// variant type size: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type size: int -> float32
							case int:
								tmpp += 5
							// addition type size: float64 -> float32
							case float64:
								tmpp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							output.WriteVarint(uint64(tmpp))
							switch v := e.(type) {
							// variant type serialize: float32
							case float32:
								// type: float32
								output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
								output.WriteFixed32(math.Float32bits(v))
							// variant type serialize: string
							case string:
								// type: string
								{
									output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
									output.WriteBuf([]byte(v))
								}
							// addition type serialize: int -> float32
							case int:
								output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
								output.WriteFixed32(math.Float32bits(float32(v)))
							// addition type serialize: float64 -> float32
							case float64:
								output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
								output.WriteFixed32(math.Float32bits(float32(v)))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
						} else {
							output.WriteBytes(0)
						}
					}
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, []variant<float32, string>>: %v", v))
			}
		}

		// property: s.Flv
		// type: variant<int32, []float32>
		if s.Flv != nil {
			tmp := 0
			switch v := s.Flv.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: []float32
			case []float32:
				// type: []float32
				if len(v) > 0 {
					tmpp := len(v) * 4
					tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, []float32>: %v", v))
			}
			output.WriteBytes(138, 2) // tag: 266 MAKE_TAG(33, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Flv.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: []float32
			case []float32:
				// type: []float32
				if len(v) > 0 {
					tmpp := len(v) * 4
					output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
					output.WriteVarint(uint64(tmpp))
					for _, e := range v {
						// list element serialize
						// type: float32
						output.WriteFixed32(math.Float32bits(e))
					}
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, []float32>: %v", v))
			}
		}

		// property: s.Dv
		// type: variant<int32, map[int32]variant<float32, string>>
		if s.Dv != nil {
			tmp := 0
			switch v := s.Dv.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: map[int32]variant<float32, string>
			case map[int32]interface{}:
				// type: map[int32]variant<float32, string>
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: variant<float32, string>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type: float32
							case float32:
								// type: float32
								tmppp += 1 + 4
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type: int -> float32
							case int:
								tmppp += 5
							// addition type: float64 -> float32
							case float64:
								tmppp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, map[int32]variant<float32, string>>: %v", v))
			}
			output.WriteBytes(146, 2) // tag: 274 MAKE_TAG(34, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Dv.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: map[int32]variant<float32, string>
			case map[int32]interface{}:
				// type: map[int32]variant<float32, string>
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key size
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value size
						// type: variant<float32, string>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type: float32
							case float32:
								// type: float32
								tmppp += 1 + 4
							// variant type: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type: int -> float32
							case int:
								tmppp += 5
							// addition type: float64 -> float32
							case float64:
								tmppp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
						}
						output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
						output.WriteVarint(uint64(tmpp))
						// dict key serialize
						// type: int32
						if k != 0 {
							output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
							output.WriteVarint(uint64(k))
						}
						// dict value serialize
						// type: variant<float32, string>
						if v != nil {
							tmppp := 0
							switch v := v.(type) {
							// variant type size: float32
							case float32:
								// type: float32
								tmppp += 1 + 4
							// variant type size: string
							case string:
								// type: string
								{
									l := len([]byte(v))
									tmppp += 1 + tygo.SizeVarint(uint64(l)) + l
								}
							// addition type size: int -> float32
							case int:
								tmppp += 5
							// addition type size: float64 -> float32
							case float64:
								tmppp += 5
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
							output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
							output.WriteVarint(uint64(tmppp))
							switch v := v.(type) {
							// variant type serialize: float32
							case float32:
								// type: float32
								output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
								output.WriteFixed32(math.Float32bits(v))
							// variant type serialize: string
							case string:
								// type: string
								{
									output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
									output.WriteBuf([]byte(v))
								}
							// addition type serialize: int -> float32
							case int:
								output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
								output.WriteFixed32(math.Float32bits(float32(v)))
							// addition type serialize: float64 -> float32
							case float64:
								output.WriteBytes(13) // tag: 13 MAKE_TAG(1, WireFixed32=5)
								output.WriteFixed32(math.Float32bits(float32(v)))
							default:
								panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<float32, string>: %v", v))
							}
						}
					}
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, map[int32]variant<float32, string>>: %v", v))
			}
		}

		// property: s.Fdv
		// type: variant<int32, map[int32]float32>
		if s.Fdv != nil {
			tmp := 0
			switch v := s.Fdv.(type) {
			// variant type size: int32
			case int32:
				// type: int32
				tmp += 1 + tygo.SizeVarint(uint64(v))
			// variant type size: map[int32]float32
			case map[int32]float32:
				// type: map[int32]float32
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value
						// type: float32
						if v != 0 {
							tmpp += 1 + 4
						}
						tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
					}
				}
			// addition type size: int
			case int:
				tmp += 1 + tygo.SizeVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, map[int32]float32>: %v", v))
			}
			output.WriteBytes(154, 2) // tag: 282 MAKE_TAG(35, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			switch v := s.Fdv.(type) {
			// variant type serialize: int32
			case int32:
				// type: int32
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			// variant type serialize: map[int32]float32
			case map[int32]float32:
				// type: map[int32]float32
				if len(v) > 0 {
					for k, v := range v {
						tmpp := 0
						// dict key size
						// type: int32
						if k != 0 {
							tmpp += 1 + tygo.SizeVarint(uint64(k))
						}
						// dict value size
						// type: float32
						if v != 0 {
							tmpp += 1 + 4
						}
						output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
						output.WriteVarint(uint64(tmpp))
						// dict key serialize
						// type: int32
						if k != 0 {
							output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
							output.WriteVarint(uint64(k))
						}
						// dict value serialize
						// type: float32
						if v != 0 {
							output.WriteBytes(21) // tag: 21 MAKE_TAG(2, WireFixed32=5)
							output.WriteFixed32(math.Float32bits(v))
						}
					}
				}
			// addition type serialize: int
			case int:
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(v))
			default:
				panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<int32, map[int32]float32>: %v", v))
			}
		}

	}
}

func (s *Fighter) Deserialize(input *tygo.ProtoBuf) (err error) {
	if err = s.Fighter_Part2.Deserialize(input); err == nil {
		input.Reset()
	} else {
		return
	}
object_tmp_40:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(1023); err != nil {
			return
		} else if cutoff {
		switch_tmp_40:
			switch (tag >> 3) - 19 {
			// property: s.V0
			case 1:
				if tag == 162 { // MAKE_TAG(20, WireBytes=2)
					// type: variant<int32, float32, bytes, *Vector2>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_41:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.V0 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_41 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 2:
									if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
										// type: float32
										if x, e := tmpi.ReadFixed32(); e == nil {
											s.V0 = math.Float32frombits(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_41 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 3:
									if tmpg == 26 { // MAKE_TAG(3, WireBytes=2)
										// type: bytes
										if x, e := tmpi.ReadBuf(); e == nil {
											s.V0 = make([]byte, len(x))
											copy(s.V0.([]byte), x)
										} else {
											err = e
											return
										}
										continue variant_tmp_41 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 4:
									if tmpg == 34 { // MAKE_TAG(4, WireBytes=2)
										// type: *Vector2
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.V0 == nil {
												s.V0 = &Vector2{}
											}
											if len(x) > 0 {
												if err = s.V0.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_41 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(170, 1) { // tag: 170 MAKE_TAG(21, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 170 // MAKE_TAG(21, WireBytes=2) // fallthrough case 2
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.V1
			case 2:
				if tag == 170 { // MAKE_TAG(21, WireBytes=2)
					// type: variant<int32, float32, bytes, *Vector2>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_42:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.V1 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_42 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 2:
									if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
										// type: float32
										if x, e := tmpi.ReadFixed32(); e == nil {
											s.V1 = math.Float32frombits(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_42 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 3:
									if tmpg == 26 { // MAKE_TAG(3, WireBytes=2)
										// type: bytes
										if x, e := tmpi.ReadBuf(); e == nil {
											s.V1 = make([]byte, len(x))
											copy(s.V1.([]byte), x)
										} else {
											err = e
											return
										}
										continue variant_tmp_42 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 4:
									if tmpg == 34 { // MAKE_TAG(4, WireBytes=2)
										// type: *Vector2
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.V1 == nil {
												s.V1 = &Vector2{}
											}
											if len(x) > 0 {
												if err = s.V1.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_42 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(178, 1) { // tag: 178 MAKE_TAG(22, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 178 // MAKE_TAG(22, WireBytes=2) // fallthrough case 3
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.V2
			case 3:
				if tag == 178 { // MAKE_TAG(22, WireBytes=2)
					// type: variant<int32, float32, bytes, *Vector2>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_43:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.V2 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_43 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 2:
									if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
										// type: float32
										if x, e := tmpi.ReadFixed32(); e == nil {
											s.V2 = math.Float32frombits(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_43 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 3:
									if tmpg == 26 { // MAKE_TAG(3, WireBytes=2)
										// type: bytes
										if x, e := tmpi.ReadBuf(); e == nil {
											s.V2 = make([]byte, len(x))
											copy(s.V2.([]byte), x)
										} else {
											err = e
											return
										}
										continue variant_tmp_43 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 4:
									if tmpg == 34 { // MAKE_TAG(4, WireBytes=2)
										// type: *Vector2
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.V2 == nil {
												s.V2 = &Vector2{}
											}
											if len(x) > 0 {
												if err = s.V2.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_43 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(186, 1) { // tag: 186 MAKE_TAG(23, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 186 // MAKE_TAG(23, WireBytes=2) // fallthrough case 4
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.V3
			case 4:
				if tag == 186 { // MAKE_TAG(23, WireBytes=2)
					// type: variant<int32, float32, bytes, *Vector2>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_44:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.V3 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_44 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 2:
									if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
										// type: float32
										if x, e := tmpi.ReadFixed32(); e == nil {
											s.V3 = math.Float32frombits(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_44 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 3:
									if tmpg == 26 { // MAKE_TAG(3, WireBytes=2)
										// type: bytes
										if x, e := tmpi.ReadBuf(); e == nil {
											s.V3 = make([]byte, len(x))
											copy(s.V3.([]byte), x)
										} else {
											err = e
											return
										}
										continue variant_tmp_44 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 4:
									if tmpg == 34 { // MAKE_TAG(4, WireBytes=2)
										// type: *Vector2
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.V3 == nil {
												s.V3 = &Vector2{}
											}
											if len(x) > 0 {
												if err = s.V3.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_44 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(194, 1) { // tag: 194 MAKE_TAG(24, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 194 // MAKE_TAG(24, WireBytes=2) // fallthrough case 5
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.V4
			case 5:
				if tag == 194 { // MAKE_TAG(24, WireBytes=2)
					// type: variant<int32, float32, bytes, *Vector2>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_45:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.V4 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_45 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 2:
									if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
										// type: float32
										if x, e := tmpi.ReadFixed32(); e == nil {
											s.V4 = math.Float32frombits(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_45 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 3:
									if tmpg == 26 { // MAKE_TAG(3, WireBytes=2)
										// type: bytes
										if x, e := tmpi.ReadBuf(); e == nil {
											s.V4 = make([]byte, len(x))
											copy(s.V4.([]byte), x)
										} else {
											err = e
											return
										}
										continue variant_tmp_45 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								case 4:
									if tmpg == 34 { // MAKE_TAG(4, WireBytes=2)
										// type: *Vector2
										if x, e := tmpi.ReadBuf(); e == nil {
											if s.V4 == nil {
												s.V4 = &Vector2{}
											}
											if len(x) > 0 {
												if err = s.V4.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
													return
												}
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_45 // next tag for variant<int32, float32, bytes, *Vector2>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(202, 1) { // tag: 202 MAKE_TAG(25, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 202 // MAKE_TAG(25, WireBytes=2) // fallthrough case 6
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Vl
			case 6:
				if tag == 202 { // MAKE_TAG(25, WireBytes=2)
				loop_tmp_46:
					// type: []variant<int32, fixedpoint<3, 0>, string, *Vector2>
					for {
						var tmp_46 interface{}
						// type: variant<int32, fixedpoint<3, 0>, string, *Vector2>
						if x, e := input.ReadBuf(); e == nil {
							tmpi := &tygo.ProtoBuf{Buffer: x}
						variant_tmp_47:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
									switch tmpg >> 3 {
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_46 = int32(x)
											} else {
												err = e
												return
											}
											continue variant_tmp_47 // next tag for variant<int32, fixedpoint<3, 0>, string, *Vector2>
										}
									case 2:
										if tmpg == 16 { // MAKE_TAG(2, WireVarint=0)
											// type: fixedpoint<3, 0>
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_46 = float64(x) / 1000
											} else {
												err = e
												return
											}
											continue variant_tmp_47 // next tag for variant<int32, fixedpoint<3, 0>, string, *Vector2>
										}
									case 3:
										if tmpg == 26 { // MAKE_TAG(3, WireBytes=2)
											// type: string
											if x, e := tmpi.ReadBuf(); e == nil {
												tmp_46 = string(x)
											} else {
												err = e
												return
											}
											continue variant_tmp_47 // next tag for variant<int32, fixedpoint<3, 0>, string, *Vector2>
										}
									case 4:
										if tmpg == 34 { // MAKE_TAG(4, WireBytes=2)
											// type: *Vector2
											if x, e := tmpi.ReadBuf(); e == nil {
												if tmp_46 == nil {
													tmp_46 = &Vector2{}
												}
												if len(x) > 0 {
													if err = tmp_46.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											continue variant_tmp_47 // next tag for variant<int32, fixedpoint<3, 0>, string, *Vector2>
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
						} else {
							err = e
							return
						}
						s.Vl = append(s.Vl, tmp_46)
						if !input.ExpectBytes(202, 1) { // tag: 202 MAKE_TAG(25, WireBytes=2)
							break loop_tmp_46 // end for []variant<int32, fixedpoint<3, 0>, string, *Vector2>
						}
					}
					if !input.ExpectBytes(210, 1) { // tag: 210 MAKE_TAG(26, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 210 // MAKE_TAG(26, WireBytes=2) // fallthrough case 7
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Vd
			case 7:
				if tag == 210 { // MAKE_TAG(26, WireBytes=2)
				loop_tmp_48:
					// type: map[int32]variant<Corpus, float64, string, *Vector2>
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Vd == nil {
								s.Vd = make(map[int32]interface{})
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_48 int32
							var tmp_49 interface{}
						dict_tmp_48:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_48:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_48 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_48 // next tag for map[int32]variant<Corpus, float64, string, *Vector2>
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_48 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: variant<Corpus, float64, string, *Vector2>
											if x, e := tmpi.ReadBuf(); e == nil {
												tmpii := &tygo.ProtoBuf{Buffer: x}
											variant_tmp_50:
												for !tmpii.ExpectEnd() {
													var tmpig int
													var cutoff bool
													if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
														return
													} else if cutoff {
														switch tmpig >> 3 {
														case 1:
															if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																// type: Corpus
																if x, e := tmpii.ReadVarint(); e == nil {
																	tmp_49 = Corpus(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_50 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 2:
															if tmpig == 17 { // MAKE_TAG(2, WireFixed64=1)
																// type: float64
																if x, e := tmpii.ReadFixed64(); e == nil {
																	tmp_49 = math.Float64frombits(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_50 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 3:
															if tmpig == 26 { // MAKE_TAG(3, WireBytes=2)
																// type: string
																if x, e := tmpii.ReadBuf(); e == nil {
																	tmp_49 = string(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_50 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 4:
															if tmpig == 34 { // MAKE_TAG(4, WireBytes=2)
																// type: *Vector2
																if x, e := tmpii.ReadBuf(); e == nil {
																	if tmp_49 == nil {
																		tmp_49 = &Vector2{}
																	}
																	if len(x) > 0 {
																		if err = tmp_49.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
																			return
																		}
																	}
																} else {
																	err = e
																	return
																}
																continue variant_tmp_50 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														}
													}
													if err = tmpii.SkipField(tmpig); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_48 // end for map[int32]variant<Corpus, float64, string, *Vector2>
											}
											continue dict_tmp_48 // next tag for map[int32]variant<Corpus, float64, string, *Vector2>
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Vd[tmp_48] = tmp_49
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(210, 1) { // tag: 210 MAKE_TAG(26, WireBytes=2)
							break loop_tmp_48 // end for map[int32]variant<Corpus, float64, string, *Vector2>
						}
					}
					if !input.ExpectBytes(218, 1) { // tag: 218 MAKE_TAG(27, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 218 // MAKE_TAG(27, WireBytes=2) // fallthrough case 8
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Ld
			case 8:
				if tag == 218 { // MAKE_TAG(27, WireBytes=2)
				loop_tmp_51:
					// type: map[int32][]variant<Corpus, float64, string, *Vector2>
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Ld == nil {
								s.Ld = make(map[int32][]interface{})
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_51 int32
							var tmp_52 []interface{}
						dict_tmp_51:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_51:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_51 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_51 // next tag for map[int32][]variant<Corpus, float64, string, *Vector2>
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_51 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
										loop_tmp_53:
											// type: []variant<Corpus, float64, string, *Vector2>
											for {
												var tmp_53 interface{}
												// type: variant<Corpus, float64, string, *Vector2>
												if x, e := tmpi.ReadBuf(); e == nil {
													tmpii := &tygo.ProtoBuf{Buffer: x}
												variant_tmp_54:
													for !tmpii.ExpectEnd() {
														var tmpig int
														var cutoff bool
														if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
															return
														} else if cutoff {
															switch tmpig >> 3 {
															case 1:
																if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																	// type: Corpus
																	if x, e := tmpii.ReadVarint(); e == nil {
																		tmp_53 = Corpus(x)
																	} else {
																		err = e
																		return
																	}
																	continue variant_tmp_54 // next tag for variant<Corpus, float64, string, *Vector2>
																}
															case 2:
																if tmpig == 17 { // MAKE_TAG(2, WireFixed64=1)
																	// type: float64
																	if x, e := tmpii.ReadFixed64(); e == nil {
																		tmp_53 = math.Float64frombits(x)
																	} else {
																		err = e
																		return
																	}
																	continue variant_tmp_54 // next tag for variant<Corpus, float64, string, *Vector2>
																}
															case 3:
																if tmpig == 26 { // MAKE_TAG(3, WireBytes=2)
																	// type: string
																	if x, e := tmpii.ReadBuf(); e == nil {
																		tmp_53 = string(x)
																	} else {
																		err = e
																		return
																	}
																	continue variant_tmp_54 // next tag for variant<Corpus, float64, string, *Vector2>
																}
															case 4:
																if tmpig == 34 { // MAKE_TAG(4, WireBytes=2)
																	// type: *Vector2
																	if x, e := tmpii.ReadBuf(); e == nil {
																		if tmp_53 == nil {
																			tmp_53 = &Vector2{}
																		}
																		if len(x) > 0 {
																			if err = tmp_53.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
																				return
																			}
																		}
																	} else {
																		err = e
																		return
																	}
																	continue variant_tmp_54 // next tag for variant<Corpus, float64, string, *Vector2>
																}
															}
														}
														if err = tmpii.SkipField(tmpig); err != nil {
															return
														}
													}
												} else {
													err = e
													return
												}
												tmp_52 = append(tmp_52, tmp_53)
												if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
													break loop_tmp_53 // end for []variant<Corpus, float64, string, *Vector2>
												}
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_51 // end for map[int32][]variant<Corpus, float64, string, *Vector2>
											}
											continue dict_tmp_51 // next tag for map[int32][]variant<Corpus, float64, string, *Vector2>
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Ld[tmp_51] = tmp_52
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(218, 1) { // tag: 218 MAKE_TAG(27, WireBytes=2)
							break loop_tmp_51 // end for map[int32][]variant<Corpus, float64, string, *Vector2>
						}
					}
					if !input.ExpectBytes(226, 1) { // tag: 226 MAKE_TAG(28, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 226 // MAKE_TAG(28, WireBytes=2) // fallthrough case 9
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Fld
			case 9:
				if tag == 226 { // MAKE_TAG(28, WireBytes=2)
				loop_tmp_55:
					// type: map[int32][]float32
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Fld == nil {
								s.Fld = make(map[int32][]float32)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_55 int32
							var tmp_56 []float32
						dict_tmp_55:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_55:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_55 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(21) { // tag: 21 MAKE_TAG(2, WireFixed32=5)
												continue dict_tmp_55 // next tag for map[int32][]float32
											}
											tmpg = 21 // fallthrough case 2
										} else {
											break switch_tmp_55 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 21 || tmpg == 18 { // MAKE_TAG(2, WireFixed32=5) || MAKE_TAG(2, WireBytes=2)
											// type: []float32
											if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
											loop_tmp_57:
												for {
													var tmp_57 float32
													// type: float32
													if x, e := tmpi.ReadFixed32(); e == nil {
														tmp_57 = math.Float32frombits(x)
													} else {
														err = e
														return
													}
													tmp_56 = append(tmp_56, tmp_57)
													if !tmpi.ExpectBytes(21) { // tag: 21 MAKE_TAG(2, WireFixed32=5)
														break loop_tmp_57 // end for []float32
													}
												}
											} else if x, e := tmpi.ReadBuf(); e == nil {
												tmpii := &tygo.ProtoBuf{Buffer: x}
												for !tmpii.ExpectEnd() {
													var tmp_57 float32
													// type: float32
													if x, e := tmpii.ReadFixed32(); e == nil {
														tmp_57 = math.Float32frombits(x)
													} else {
														err = e
														return
													}
													tmp_56 = append(tmp_56, tmp_57)
												}
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_55 // end for map[int32][]float32
											}
											continue dict_tmp_55 // next tag for map[int32][]float32
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Fld[tmp_55] = tmp_56
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(226, 1) { // tag: 226 MAKE_TAG(28, WireBytes=2)
							break loop_tmp_55 // end for map[int32][]float32
						}
					}
					if !input.ExpectBytes(234, 1) { // tag: 234 MAKE_TAG(29, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 234 // MAKE_TAG(29, WireBytes=2) // fallthrough case 10
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Dd
			case 10:
				if tag == 234 { // MAKE_TAG(29, WireBytes=2)
				loop_tmp_58:
					// type: map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Dd == nil {
								s.Dd = make(map[int32]map[int32]interface{})
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_58 int32
							var tmp_59 map[int32]interface{}
						dict_tmp_58:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_58:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_58 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_58 // next tag for map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_58 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
										loop_tmp_60:
											// type: map[int32]variant<int32, Corpus, float64, string, *Vector2>
											for {
												if x, e := tmpi.ReadBuf(); e == nil {
													if tmp_59 == nil {
														tmp_59 = make(map[int32]interface{})
													}
													tmpii := &tygo.ProtoBuf{Buffer: x}
													var tmp_60 int32
													var tmp_61 interface{}
												dict_tmp_60:
													for !tmpii.ExpectEnd() {
														var tmpig int
														var cutoff bool
														if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
															return
														} else if cutoff {
														switch_tmp_60:
															switch tmpig >> 3 {
															// dict key
															case 1:
																if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																	// type: int32
																	if x, e := tmpii.ReadVarint(); e == nil {
																		tmp_60 = int32(x)
																	} else {
																		err = e
																		return
																	}
																	if !tmpii.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
																		continue dict_tmp_60 // next tag for map[int32]variant<int32, Corpus, float64, string, *Vector2>
																	}
																	tmpig = 18 // fallthrough case 2
																} else {
																	break switch_tmp_60 // skip tag
																}
																fallthrough
															case 2:
																if tmpig == 18 { // MAKE_TAG(2, WireBytes=2)
																	// type: variant<int32, Corpus, float64, string, *Vector2>
																	if x, e := tmpii.ReadBuf(); e == nil {
																		tmpiii := &tygo.ProtoBuf{Buffer: x}
																	variant_tmp_62:
																		for !tmpiii.ExpectEnd() {
																			var tmpiig int
																			var cutoff bool
																			if tmpiig, cutoff, err = tmpiii.ReadTag(127); err != nil {
																				return
																			} else if cutoff {
																				switch tmpiig >> 3 {
																				case 1:
																					if tmpiig == 8 { // MAKE_TAG(1, WireVarint=0)
																						// type: int32
																						if x, e := tmpiii.ReadVarint(); e == nil {
																							tmp_61 = int32(x)
																						} else {
																							err = e
																							return
																						}
																						continue variant_tmp_62 // next tag for variant<int32, Corpus, float64, string, *Vector2>
																					}
																				case 2:
																					if tmpiig == 16 { // MAKE_TAG(2, WireVarint=0)
																						// type: Corpus
																						if x, e := tmpiii.ReadVarint(); e == nil {
																							tmp_61 = Corpus(x)
																						} else {
																							err = e
																							return
																						}
																						continue variant_tmp_62 // next tag for variant<int32, Corpus, float64, string, *Vector2>
																					}
																				case 3:
																					if tmpiig == 25 { // MAKE_TAG(3, WireFixed64=1)
																						// type: float64
																						if x, e := tmpiii.ReadFixed64(); e == nil {
																							tmp_61 = math.Float64frombits(x)
																						} else {
																							err = e
																							return
																						}
																						continue variant_tmp_62 // next tag for variant<int32, Corpus, float64, string, *Vector2>
																					}
																				case 4:
																					if tmpiig == 34 { // MAKE_TAG(4, WireBytes=2)
																						// type: string
																						if x, e := tmpiii.ReadBuf(); e == nil {
																							tmp_61 = string(x)
																						} else {
																							err = e
																							return
																						}
																						continue variant_tmp_62 // next tag for variant<int32, Corpus, float64, string, *Vector2>
																					}
																				case 5:
																					if tmpiig == 42 { // MAKE_TAG(5, WireBytes=2)
																						// type: *Vector2
																						if x, e := tmpiii.ReadBuf(); e == nil {
																							if tmp_61 == nil {
																								tmp_61 = &Vector2{}
																							}
																							if len(x) > 0 {
																								if err = tmp_61.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
																									return
																								}
																							}
																						} else {
																							err = e
																							return
																						}
																						continue variant_tmp_62 // next tag for variant<int32, Corpus, float64, string, *Vector2>
																					}
																				}
																			}
																			if err = tmpiii.SkipField(tmpiig); err != nil {
																				return
																			}
																		}
																	} else {
																		err = e
																		return
																	}
																	if tmpii.ExpectEnd() {
																		break dict_tmp_60 // end for map[int32]variant<int32, Corpus, float64, string, *Vector2>
																	}
																	continue dict_tmp_60 // next tag for map[int32]variant<int32, Corpus, float64, string, *Vector2>
																}
															}
														}
														if err = tmpii.SkipField(tmpig); err != nil {
															return
														}
													}
													tmp_59[tmp_60] = tmp_61
												} else {
													err = e
													return
												}
												if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
													break loop_tmp_60 // end for map[int32]variant<int32, Corpus, float64, string, *Vector2>
												}
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_58 // end for map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
											}
											continue dict_tmp_58 // next tag for map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Dd[tmp_58] = tmp_59
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(234, 1) { // tag: 234 MAKE_TAG(29, WireBytes=2)
							break loop_tmp_58 // end for map[int32]map[int32]variant<int32, Corpus, float64, string, *Vector2>
						}
					}
					if !input.ExpectBytes(242, 1) { // tag: 242 MAKE_TAG(30, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 242 // MAKE_TAG(30, WireBytes=2) // fallthrough case 11
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Fdd
			case 11:
				if tag == 242 { // MAKE_TAG(30, WireBytes=2)
				loop_tmp_63:
					// type: map[int32]map[int32]float32
					for {
						if x, e := input.ReadBuf(); e == nil {
							if s.Fdd == nil {
								s.Fdd = make(map[int32]map[int32]float32)
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_63 int32
							var tmp_64 map[int32]float32
						dict_tmp_63:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_63:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_63 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_63 // next tag for map[int32]map[int32]float32
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_63 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
										loop_tmp_65:
											// type: map[int32]float32
											for {
												if x, e := tmpi.ReadBuf(); e == nil {
													if tmp_64 == nil {
														tmp_64 = make(map[int32]float32)
													}
													tmpii := &tygo.ProtoBuf{Buffer: x}
													var tmp_65 int32
													var tmp_66 float32
												dict_tmp_65:
													for !tmpii.ExpectEnd() {
														var tmpig int
														var cutoff bool
														if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
															return
														} else if cutoff {
														switch_tmp_65:
															switch tmpig >> 3 {
															// dict key
															case 1:
																if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																	// type: int32
																	if x, e := tmpii.ReadVarint(); e == nil {
																		tmp_65 = int32(x)
																	} else {
																		err = e
																		return
																	}
																	if !tmpii.ExpectBytes(21) { // tag: 21 MAKE_TAG(2, WireFixed32=5)
																		continue dict_tmp_65 // next tag for map[int32]float32
																	}
																	tmpig = 21 // fallthrough case 2
																} else {
																	break switch_tmp_65 // skip tag
																}
																fallthrough
															case 2:
																if tmpig == 21 { // MAKE_TAG(2, WireFixed32=5)
																	// type: float32
																	if x, e := tmpii.ReadFixed32(); e == nil {
																		tmp_66 = math.Float32frombits(x)
																	} else {
																		err = e
																		return
																	}
																	if tmpii.ExpectEnd() {
																		break dict_tmp_65 // end for map[int32]float32
																	}
																	continue dict_tmp_65 // next tag for map[int32]float32
																}
															}
														}
														if err = tmpii.SkipField(tmpig); err != nil {
															return
														}
													}
													tmp_64[tmp_65] = tmp_66
												} else {
													err = e
													return
												}
												if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
													break loop_tmp_65 // end for map[int32]float32
												}
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_63 // end for map[int32]map[int32]float32
											}
											continue dict_tmp_63 // next tag for map[int32]map[int32]float32
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							s.Fdd[tmp_63] = tmp_64
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(242, 1) { // tag: 242 MAKE_TAG(30, WireBytes=2)
							break loop_tmp_63 // end for map[int32]map[int32]float32
						}
					}
					if !input.ExpectBytes(250, 1) { // tag: 250 MAKE_TAG(31, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 250 // MAKE_TAG(31, WireBytes=2) // fallthrough case 12
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Nv
			case 12:
				if tag == 250 { // MAKE_TAG(31, WireBytes=2)
					// type: variant<nil, int32>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_67:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 2:
									if tmpg == 16 { // MAKE_TAG(2, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Nv = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_67 // next tag for variant<nil, int32>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(130, 2) { // tag: 258 MAKE_TAG(32, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 258 // MAKE_TAG(32, WireBytes=2) // fallthrough case 13
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Lv
			case 13:
				if tag == 258 { // MAKE_TAG(32, WireBytes=2)
					// type: variant<int32, []variant<float32, string>>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_68:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Lv = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_68 // next tag for variant<int32, []variant<float32, string>>
									}
								case 2:
									if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
									loop_tmp_69:
										// type: []variant<float32, string>
										for {
											var tmp_69 interface{}
											// type: variant<float32, string>
											if x, e := tmpi.ReadBuf(); e == nil {
												tmpii := &tygo.ProtoBuf{Buffer: x}
											variant_tmp_70:
												for !tmpii.ExpectEnd() {
													var tmpig int
													var cutoff bool
													if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
														return
													} else if cutoff {
														switch tmpig >> 3 {
														case 1:
															if tmpig == 13 { // MAKE_TAG(1, WireFixed32=5)
																// type: float32
																if x, e := tmpii.ReadFixed32(); e == nil {
																	tmp_69 = math.Float32frombits(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_70 // next tag for variant<float32, string>
															}
														case 2:
															if tmpig == 18 { // MAKE_TAG(2, WireBytes=2)
																// type: string
																if x, e := tmpii.ReadBuf(); e == nil {
																	tmp_69 = string(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_70 // next tag for variant<float32, string>
															}
														}
													}
													if err = tmpii.SkipField(tmpig); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											if s.Lv == nil {
												s.Lv = []interface{}(nil)
											}
											s.Lv = append(s.Lv.([]interface{}), tmp_69)
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												break loop_tmp_69 // end for []variant<float32, string>
											}
										}
										continue variant_tmp_68 // next tag for variant<int32, []variant<float32, string>>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(138, 2) { // tag: 266 MAKE_TAG(33, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 266 // MAKE_TAG(33, WireBytes=2) // fallthrough case 14
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Flv
			case 14:
				if tag == 266 { // MAKE_TAG(33, WireBytes=2)
					// type: variant<int32, []float32>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_71:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Flv = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_71 // next tag for variant<int32, []float32>
									}
								case 2:
									if tmpg == 21 || tmpg == 18 { // MAKE_TAG(2, WireFixed32=5) || MAKE_TAG(2, WireBytes=2)
										// type: []float32
										if tmpg == 21 { // MAKE_TAG(2, WireFixed32=5)
										loop_tmp_72:
											for {
												var tmp_72 float32
												// type: float32
												if x, e := tmpi.ReadFixed32(); e == nil {
													tmp_72 = math.Float32frombits(x)
												} else {
													err = e
													return
												}
												if s.Flv == nil {
													s.Flv = []float32(nil)
												}
												s.Flv = append(s.Flv.([]float32), tmp_72)
												if !tmpi.ExpectBytes(21) { // tag: 21 MAKE_TAG(2, WireFixed32=5)
													break loop_tmp_72 // end for []float32
												}
											}
										} else if x, e := tmpi.ReadBuf(); e == nil {
											tmpii := &tygo.ProtoBuf{Buffer: x}
											for !tmpii.ExpectEnd() {
												var tmp_72 float32
												// type: float32
												if x, e := tmpii.ReadFixed32(); e == nil {
													tmp_72 = math.Float32frombits(x)
												} else {
													err = e
													return
												}
												if s.Flv == nil {
													s.Flv = []float32(nil)
												}
												s.Flv = append(s.Flv.([]float32), tmp_72)
											}
										} else {
											err = e
											return
										}
										continue variant_tmp_71 // next tag for variant<int32, []float32>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(146, 2) { // tag: 274 MAKE_TAG(34, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 274 // MAKE_TAG(34, WireBytes=2) // fallthrough case 15
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Dv
			case 15:
				if tag == 274 { // MAKE_TAG(34, WireBytes=2)
					// type: variant<int32, map[int32]variant<float32, string>>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_73:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Dv = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_73 // next tag for variant<int32, map[int32]variant<float32, string>>
									}
								case 2:
									if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
									loop_tmp_74:
										// type: map[int32]variant<float32, string>
										for {
											if x, e := tmpi.ReadBuf(); e == nil {
												if s.Dv == nil {
													s.Dv = make(map[int32]interface{})
												}
												tmpii := &tygo.ProtoBuf{Buffer: x}
												var tmp_74 int32
												var tmp_75 interface{}
											dict_tmp_74:
												for !tmpii.ExpectEnd() {
													var tmpig int
													var cutoff bool
													if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
														return
													} else if cutoff {
													switch_tmp_74:
														switch tmpig >> 3 {
														// dict key
														case 1:
															if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																// type: int32
																if x, e := tmpii.ReadVarint(); e == nil {
																	tmp_74 = int32(x)
																} else {
																	err = e
																	return
																}
																if !tmpii.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
																	continue dict_tmp_74 // next tag for map[int32]variant<float32, string>
																}
																tmpig = 18 // fallthrough case 2
															} else {
																break switch_tmp_74 // skip tag
															}
															fallthrough
														case 2:
															if tmpig == 18 { // MAKE_TAG(2, WireBytes=2)
																// type: variant<float32, string>
																if x, e := tmpii.ReadBuf(); e == nil {
																	tmpiii := &tygo.ProtoBuf{Buffer: x}
																variant_tmp_76:
																	for !tmpiii.ExpectEnd() {
																		var tmpiig int
																		var cutoff bool
																		if tmpiig, cutoff, err = tmpiii.ReadTag(127); err != nil {
																			return
																		} else if cutoff {
																			switch tmpiig >> 3 {
																			case 1:
																				if tmpiig == 13 { // MAKE_TAG(1, WireFixed32=5)
																					// type: float32
																					if x, e := tmpiii.ReadFixed32(); e == nil {
																						tmp_75 = math.Float32frombits(x)
																					} else {
																						err = e
																						return
																					}
																					continue variant_tmp_76 // next tag for variant<float32, string>
																				}
																			case 2:
																				if tmpiig == 18 { // MAKE_TAG(2, WireBytes=2)
																					// type: string
																					if x, e := tmpiii.ReadBuf(); e == nil {
																						tmp_75 = string(x)
																					} else {
																						err = e
																						return
																					}
																					continue variant_tmp_76 // next tag for variant<float32, string>
																				}
																			}
																		}
																		if err = tmpiii.SkipField(tmpiig); err != nil {
																			return
																		}
																	}
																} else {
																	err = e
																	return
																}
																if tmpii.ExpectEnd() {
																	break dict_tmp_74 // end for map[int32]variant<float32, string>
																}
																continue dict_tmp_74 // next tag for map[int32]variant<float32, string>
															}
														}
													}
													if err = tmpii.SkipField(tmpig); err != nil {
														return
													}
												}
												s.Dv.(map[int32]interface{})[tmp_74] = tmp_75
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												break loop_tmp_74 // end for map[int32]variant<float32, string>
											}
										}
										continue variant_tmp_73 // next tag for variant<int32, map[int32]variant<float32, string>>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(154, 2) { // tag: 282 MAKE_TAG(35, WireBytes=2)
						continue object_tmp_40 // next tag for Fighter
					}
					tag = 282 // MAKE_TAG(35, WireBytes=2) // fallthrough case 16
				} else {
					break switch_tmp_40 // skip tag
				}
				fallthrough
			// property: s.Fdv
			case 16:
				if tag == 282 { // MAKE_TAG(35, WireBytes=2)
					// type: variant<int32, map[int32]float32>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_77:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 1:
									if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											s.Fdv = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_77 // next tag for variant<int32, map[int32]float32>
									}
								case 2:
									if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
									loop_tmp_78:
										// type: map[int32]float32
										for {
											if x, e := tmpi.ReadBuf(); e == nil {
												if s.Fdv == nil {
													s.Fdv = make(map[int32]float32)
												}
												tmpii := &tygo.ProtoBuf{Buffer: x}
												var tmp_78 int32
												var tmp_79 float32
											dict_tmp_78:
												for !tmpii.ExpectEnd() {
													var tmpig int
													var cutoff bool
													if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
														return
													} else if cutoff {
													switch_tmp_78:
														switch tmpig >> 3 {
														// dict key
														case 1:
															if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																// type: int32
																if x, e := tmpii.ReadVarint(); e == nil {
																	tmp_78 = int32(x)
																} else {
																	err = e
																	return
																}
																if !tmpii.ExpectBytes(21) { // tag: 21 MAKE_TAG(2, WireFixed32=5)
																	continue dict_tmp_78 // next tag for map[int32]float32
																}
																tmpig = 21 // fallthrough case 2
															} else {
																break switch_tmp_78 // skip tag
															}
															fallthrough
														case 2:
															if tmpig == 21 { // MAKE_TAG(2, WireFixed32=5)
																// type: float32
																if x, e := tmpii.ReadFixed32(); e == nil {
																	tmp_79 = math.Float32frombits(x)
																} else {
																	err = e
																	return
																}
																if tmpii.ExpectEnd() {
																	break dict_tmp_78 // end for map[int32]float32
																}
																continue dict_tmp_78 // next tag for map[int32]float32
															}
														}
													}
													if err = tmpii.SkipField(tmpig); err != nil {
														return
													}
												}
												s.Fdv.(map[int32]float32)[tmp_78] = tmp_79
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												break loop_tmp_78 // end for map[int32]float32
											}
										}
										continue variant_tmp_77 // next tag for variant<int32, map[int32]float32>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if input.ExpectEnd() {
						break object_tmp_40 // end for Fighter
					}
					continue object_tmp_40 // next tag for Fighter
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

// RPG Param(a0: *Fighter, a1: variant<nil, int32>, a2: fixedpoint<3, 0>)
func (s *Fighter) SerializeRPGParam(a0 *Fighter, a1 interface{}, a2 float64) (data []byte) {
	size := 0
	// param size: a0
	// type: *Fighter
	if a0 != nil {
		tmp := a0.ByteSize()
		size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
	}

	// param size: a1
	// type: variant<nil, int32>
	if a1 != nil {
		tmp := 0
		switch v := a1.(type) {
		// variant type: int32
		case int32:
			// type: int32
			tmp += 1 + tygo.SizeVarint(uint64(v))
		// addition type: int
		case int:
			tmp += 1 + tygo.SizeVarint(uint64(v))
		default:
			panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
		}
		size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
	}

	// param size: a2
	// type: fixedpoint<3, 0>
	if a2 != 0 {
		size += 1 + tygo.SizeVarint(uint64(a2 * 1000))
	}

	if size <= 0 {
		return
	}
	data = make([]byte, size)
	output := &tygo.ProtoBuf{Buffer: data}

	// param serialize: a0
	// type: *Fighter
	if a0 != nil {
		output.WriteBytes(10) // tag: 10 MAKE_TAG(1, WireBytes=2)
		output.WriteVarint(uint64(a0.CachedSize()))
		a0.Serialize(output)
	}

	// param serialize: a1
	// type: variant<nil, int32>
	if a1 != nil {
		tmp := 0
		switch v := a1.(type) {
		// variant type size: int32
		case int32:
			// type: int32
			tmp += 1 + tygo.SizeVarint(uint64(v))
		// addition type size: int
		case int:
			tmp += 1 + tygo.SizeVarint(uint64(v))
		default:
			panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
		}
		output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
		output.WriteVarint(uint64(tmp))
		switch v := a1.(type) {
		// variant type serialize: int32
		case int32:
			// type: int32
			output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
			output.WriteVarint(uint64(v))
		// addition type serialize: int
		case int:
			output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
			output.WriteVarint(uint64(v))
		default:
			panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
		}
	}

	// param serialize: a2
	// type: fixedpoint<3, 0>
	if a2 != 0 {
		output.WriteBytes(24) // tag: 24 MAKE_TAG(3, WireVarint=0)
		output.WriteVarint(uint64(a2 * 1000))
	}

	return
}

// RPG Param(a0: *Fighter, a1: variant<nil, int32>, a2: fixedpoint<3, 0>)
func (s *Fighter) DeserializeRPGParam(data []byte) (a0 *Fighter, a1 interface{}, a2 float64, err error) {
	input := &tygo.ProtoBuf{Buffer: data}
method_tmp_28:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(((3 << 3) | 7)); err != nil {
			return
		} else if cutoff {
		switch_tmp_28:
			switch tag >> 3 {
			// param deserialize: a0
			case 1:
				if tag == 10 { // MAKE_TAG(1, WireBytes=2)
					// type: variant<nil, int32>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_29:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 2:
									if tmpg == 16 { // MAKE_TAG(2, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											a1 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_29 // next tag for variant<nil, int32>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
						continue method_tmp_28 // next tag for param
					}
					tag = 18 // MAKE_TAG(2, WireBytes=2) // fallthrough case 2
				} else {
					break switch_tmp_28 // skip tag
				}
				fallthrough
			// param deserialize: a1
			case 2:
				if tag == 16 { // MAKE_TAG(2, WireVarint=0)
					// type: fixedpoint<3, 0>
					if x, e := input.ReadVarint(); e == nil {
						a2 = float64(x) / 1000
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(24) { // tag: 24 MAKE_TAG(3, WireVarint=0)
						continue method_tmp_28 // next tag for param
					}
					tag = 24 // MAKE_TAG(3, WireVarint=0) // fallthrough case 3
				} else {
					break switch_tmp_28 // skip tag
				}
				fallthrough
			// param deserialize: a2
			case 3:
				if tag == 24 { // MAKE_TAG(3, WireVarint=0)
					// type: fixedpoint<3, 0>
					if x, e := input.ReadVarint(); e == nil {
						a2 = float64(x) / 1000
					} else {
						err = e
						return
					}
					if input.ExpectEnd() {
						break method_tmp_28 // end for param
					}
					continue method_tmp_28 // next tag for param
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

// RPG Result(a0: *Fighter, a1: variant<nil, int32>, a2: fixedpoint<3, 0>)
func (s *Fighter) SerializeRPGResult(a0 *Fighter, a1 interface{}, a2 float64) (data []byte) {
	size := 0
	// result size: a0
	// type: *Fighter
	if a0 != nil {
		tmp := a0.ByteSize()
		size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
	}

	// result size: a1
	// type: variant<nil, int32>
	if a1 != nil {
		tmp := 0
		switch v := a1.(type) {
		// variant type: int32
		case int32:
			// type: int32
			tmp += 1 + tygo.SizeVarint(uint64(v))
		// addition type: int
		case int:
			tmp += 1 + tygo.SizeVarint(uint64(v))
		default:
			panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
		}
		size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
	}

	// result size: a2
	// type: fixedpoint<3, 0>
	if a2 != 0 {
		size += 1 + tygo.SizeVarint(uint64(a2 * 1000))
	}

	if size <= 0 {
		return
	}
	data = make([]byte, size)
	output := &tygo.ProtoBuf{Buffer: data}

	// result serialize: a0
	// type: *Fighter
	if a0 != nil {
		output.WriteBytes(10) // tag: 10 MAKE_TAG(1, WireBytes=2)
		output.WriteVarint(uint64(a0.CachedSize()))
		a0.Serialize(output)
	}

	// result serialize: a1
	// type: variant<nil, int32>
	if a1 != nil {
		tmp := 0
		switch v := a1.(type) {
		// variant type size: int32
		case int32:
			// type: int32
			tmp += 1 + tygo.SizeVarint(uint64(v))
		// addition type size: int
		case int:
			tmp += 1 + tygo.SizeVarint(uint64(v))
		default:
			panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
		}
		output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
		output.WriteVarint(uint64(tmp))
		switch v := a1.(type) {
		// variant type serialize: int32
		case int32:
			// type: int32
			output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
			output.WriteVarint(uint64(v))
		// addition type serialize: int
		case int:
			output.WriteBytes(16) // tag: 16 MAKE_TAG(2, WireVarint=0)
			output.WriteVarint(uint64(v))
		default:
			panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<nil, int32>: %v", v))
		}
	}

	// result serialize: a2
	// type: fixedpoint<3, 0>
	if a2 != 0 {
		output.WriteBytes(24) // tag: 24 MAKE_TAG(3, WireVarint=0)
		output.WriteVarint(uint64(a2 * 1000))
	}

	return
}

// RPG Result(a0: *Fighter, a1: variant<nil, int32>, a2: fixedpoint<3, 0>)
func (s *Fighter) DeserializeRPGResult(data []byte) (a0 *Fighter, a1 interface{}, a2 float64, err error) {
	input := &tygo.ProtoBuf{Buffer: data}
method_tmp_30:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(((3 << 3) | 7)); err != nil {
			return
		} else if cutoff {
		switch_tmp_30:
			switch tag >> 3 {
			// result deserialize: a0
			case 1:
				if tag == 10 { // MAKE_TAG(1, WireBytes=2)
					// type: variant<nil, int32>
					if x, e := input.ReadBuf(); e == nil {
						tmpi := &tygo.ProtoBuf{Buffer: x}
					variant_tmp_31:
						for !tmpi.ExpectEnd() {
							var tmpg int
							var cutoff bool
							if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
								return
							} else if cutoff {
								switch tmpg >> 3 {
								case 2:
									if tmpg == 16 { // MAKE_TAG(2, WireVarint=0)
										// type: int32
										if x, e := tmpi.ReadVarint(); e == nil {
											a1 = int32(x)
										} else {
											err = e
											return
										}
										continue variant_tmp_31 // next tag for variant<nil, int32>
									}
								}
							}
							if err = tmpi.SkipField(tmpg); err != nil {
								return
							}
						}
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
						continue method_tmp_30 // next tag for result
					}
					tag = 18 // MAKE_TAG(2, WireBytes=2) // fallthrough case 2
				} else {
					break switch_tmp_30 // skip tag
				}
				fallthrough
			// result deserialize: a1
			case 2:
				if tag == 16 { // MAKE_TAG(2, WireVarint=0)
					// type: fixedpoint<3, 0>
					if x, e := input.ReadVarint(); e == nil {
						a2 = float64(x) / 1000
					} else {
						err = e
						return
					}
					if !input.ExpectBytes(24) { // tag: 24 MAKE_TAG(3, WireVarint=0)
						continue method_tmp_30 // next tag for result
					}
					tag = 24 // MAKE_TAG(3, WireVarint=0) // fallthrough case 3
				} else {
					break switch_tmp_30 // skip tag
				}
				fallthrough
			// result deserialize: a2
			case 3:
				if tag == 24 { // MAKE_TAG(3, WireVarint=0)
					// type: fixedpoint<3, 0>
					if x, e := input.ReadVarint(); e == nil {
						a2 = float64(x) / 1000
					} else {
						err = e
						return
					}
					if input.ExpectEnd() {
						break method_tmp_30 // end for result
					}
					continue method_tmp_30 // next tag for result
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

// GPR Param(a0: map[int32]variant<Corpus, float64, string, *Vector2>)
func (s *Fighter) SerializeGPRParam(a0 map[int32]interface{}) (data []byte) {
	size := 0
	// param size: a0
	// type: map[int32]variant<Corpus, float64, string, *Vector2>
	if len(a0) > 0 {
		for k, v := range a0 {
			tmp := 0
			// dict key
			// type: int32
			if k != 0 {
				tmp += 1 + tygo.SizeVarint(uint64(k))
			}
			// dict value
			// type: variant<Corpus, float64, string, *Vector2>
			if v != nil {
				tmpp := 0
				switch v := v.(type) {
				// variant type: Corpus
				case Corpus:
					// type: Corpus
					tmpp += 1 + tygo.SizeVarint(uint64(v))
				// variant type: float64
				case float64:
					// type: float64
					tmpp += 1 + 8
				// variant type: string
				case string:
					// type: string
					{
						l := len([]byte(v))
						tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
					}
				// variant type: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						tmppp := v.ByteSize()
						tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
					}
				// addition type: int -> float64
				case int:
					tmpp += 9
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
				tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
			}
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}
	}

	if size <= 0 {
		return
	}
	data = make([]byte, size)
	output := &tygo.ProtoBuf{Buffer: data}

	// param serialize: a0
	// type: map[int32]variant<Corpus, float64, string, *Vector2>
	if len(a0) > 0 {
		for k, v := range a0 {
			tmp := 0
			// dict key size
			// type: int32
			if k != 0 {
				tmp += 1 + tygo.SizeVarint(uint64(k))
			}
			// dict value size
			// type: variant<Corpus, float64, string, *Vector2>
			if v != nil {
				tmpp := 0
				switch v := v.(type) {
				// variant type: Corpus
				case Corpus:
					// type: Corpus
					tmpp += 1 + tygo.SizeVarint(uint64(v))
				// variant type: float64
				case float64:
					// type: float64
					tmpp += 1 + 8
				// variant type: string
				case string:
					// type: string
					{
						l := len([]byte(v))
						tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
					}
				// variant type: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						tmppp := v.CachedSize()
						tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
					}
				// addition type: int -> float64
				case int:
					tmpp += 9
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
				tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
			}
			output.WriteBytes(10) // tag: 10 MAKE_TAG(1, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			// dict key serialize
			// type: int32
			if k != 0 {
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(k))
			}
			// dict value serialize
			// type: variant<Corpus, float64, string, *Vector2>
			if v != nil {
				tmpp := 0
				switch v := v.(type) {
				// variant type size: Corpus
				case Corpus:
					// type: Corpus
					tmpp += 1 + tygo.SizeVarint(uint64(v))
				// variant type size: float64
				case float64:
					// type: float64
					tmpp += 1 + 8
				// variant type size: string
				case string:
					// type: string
					{
						l := len([]byte(v))
						tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
					}
				// variant type size: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						tmppp := v.CachedSize()
						tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
					}
				// addition type size: int -> float64
				case int:
					tmpp += 9
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
				output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
				output.WriteVarint(uint64(tmpp))
				switch v := v.(type) {
				// variant type serialize: Corpus
				case Corpus:
					// type: Corpus
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(v))
				// variant type serialize: float64
				case float64:
					// type: float64
					output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
					output.WriteFixed64(math.Float64bits(v))
				// variant type serialize: string
				case string:
					// type: string
					{
						output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
						output.WriteBuf([]byte(v))
					}
				// variant type serialize: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
						output.WriteVarint(uint64(v.CachedSize()))
						v.Serialize(output)
					}
				// addition type serialize: int -> float64
				case int:
					output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
					output.WriteFixed64(math.Float64bits(float64(v)))
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
			}
		}
	}

	return
}

// GPR Param(a0: map[int32]variant<Corpus, float64, string, *Vector2>)
func (s *Fighter) DeserializeGPRParam(data []byte) (a0 map[int32]interface{}, err error) {
	input := &tygo.ProtoBuf{Buffer: data}
method_tmp_32:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(((1 << 3) | 7)); err != nil {
			return
		} else if cutoff {
			switch tag >> 3 {
			// param deserialize: a0
			case 1:
				if tag == 10 { // MAKE_TAG(1, WireBytes=2)
				loop_tmp_33:
					// type: map[int32]variant<Corpus, float64, string, *Vector2>
					for {
						if x, e := input.ReadBuf(); e == nil {
							if a0 == nil {
								a0 = make(map[int32]interface{})
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_33 int32
							var tmp_34 interface{}
						dict_tmp_33:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_33:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_33 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_33 // next tag for map[int32]variant<Corpus, float64, string, *Vector2>
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_33 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: variant<Corpus, float64, string, *Vector2>
											if x, e := tmpi.ReadBuf(); e == nil {
												tmpii := &tygo.ProtoBuf{Buffer: x}
											variant_tmp_35:
												for !tmpii.ExpectEnd() {
													var tmpig int
													var cutoff bool
													if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
														return
													} else if cutoff {
														switch tmpig >> 3 {
														case 1:
															if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																// type: Corpus
																if x, e := tmpii.ReadVarint(); e == nil {
																	tmp_34 = Corpus(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_35 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 2:
															if tmpig == 17 { // MAKE_TAG(2, WireFixed64=1)
																// type: float64
																if x, e := tmpii.ReadFixed64(); e == nil {
																	tmp_34 = math.Float64frombits(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_35 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 3:
															if tmpig == 26 { // MAKE_TAG(3, WireBytes=2)
																// type: string
																if x, e := tmpii.ReadBuf(); e == nil {
																	tmp_34 = string(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_35 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 4:
															if tmpig == 34 { // MAKE_TAG(4, WireBytes=2)
																// type: *Vector2
																if x, e := tmpii.ReadBuf(); e == nil {
																	if tmp_34 == nil {
																		tmp_34 = &Vector2{}
																	}
																	if len(x) > 0 {
																		if err = tmp_34.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
																			return
																		}
																	}
																} else {
																	err = e
																	return
																}
																continue variant_tmp_35 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														}
													}
													if err = tmpii.SkipField(tmpig); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_33 // end for map[int32]variant<Corpus, float64, string, *Vector2>
											}
											continue dict_tmp_33 // next tag for map[int32]variant<Corpus, float64, string, *Vector2>
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							a0[tmp_33] = tmp_34
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(10) { // tag: 10 MAKE_TAG(1, WireBytes=2)
							break loop_tmp_33 // end for map[int32]variant<Corpus, float64, string, *Vector2>
						}
					}
					if input.ExpectEnd() {
						break method_tmp_32 // end for param
					}
					continue method_tmp_32 // next tag for param
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}

// GPR Result(a0: map[int32]variant<Corpus, float64, string, *Vector2>)
func (s *Fighter) SerializeGPRResult(a0 map[int32]interface{}) (data []byte) {
	size := 0
	// result size: a0
	// type: map[int32]variant<Corpus, float64, string, *Vector2>
	if len(a0) > 0 {
		for k, v := range a0 {
			tmp := 0
			// dict key
			// type: int32
			if k != 0 {
				tmp += 1 + tygo.SizeVarint(uint64(k))
			}
			// dict value
			// type: variant<Corpus, float64, string, *Vector2>
			if v != nil {
				tmpp := 0
				switch v := v.(type) {
				// variant type: Corpus
				case Corpus:
					// type: Corpus
					tmpp += 1 + tygo.SizeVarint(uint64(v))
				// variant type: float64
				case float64:
					// type: float64
					tmpp += 1 + 8
				// variant type: string
				case string:
					// type: string
					{
						l := len([]byte(v))
						tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
					}
				// variant type: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						tmppp := v.ByteSize()
						tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
					}
				// addition type: int -> float64
				case int:
					tmpp += 9
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
				tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
			}
			size += 1 + tygo.SizeVarint(uint64(tmp)) + tmp
		}
	}

	if size <= 0 {
		return
	}
	data = make([]byte, size)
	output := &tygo.ProtoBuf{Buffer: data}

	// result serialize: a0
	// type: map[int32]variant<Corpus, float64, string, *Vector2>
	if len(a0) > 0 {
		for k, v := range a0 {
			tmp := 0
			// dict key size
			// type: int32
			if k != 0 {
				tmp += 1 + tygo.SizeVarint(uint64(k))
			}
			// dict value size
			// type: variant<Corpus, float64, string, *Vector2>
			if v != nil {
				tmpp := 0
				switch v := v.(type) {
				// variant type: Corpus
				case Corpus:
					// type: Corpus
					tmpp += 1 + tygo.SizeVarint(uint64(v))
				// variant type: float64
				case float64:
					// type: float64
					tmpp += 1 + 8
				// variant type: string
				case string:
					// type: string
					{
						l := len([]byte(v))
						tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
					}
				// variant type: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						tmppp := v.CachedSize()
						tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
					}
				// addition type: int -> float64
				case int:
					tmpp += 9
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
				tmp += 1 + tygo.SizeVarint(uint64(tmpp)) + tmpp
			}
			output.WriteBytes(10) // tag: 10 MAKE_TAG(1, WireBytes=2)
			output.WriteVarint(uint64(tmp))
			// dict key serialize
			// type: int32
			if k != 0 {
				output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
				output.WriteVarint(uint64(k))
			}
			// dict value serialize
			// type: variant<Corpus, float64, string, *Vector2>
			if v != nil {
				tmpp := 0
				switch v := v.(type) {
				// variant type size: Corpus
				case Corpus:
					// type: Corpus
					tmpp += 1 + tygo.SizeVarint(uint64(v))
				// variant type size: float64
				case float64:
					// type: float64
					tmpp += 1 + 8
				// variant type size: string
				case string:
					// type: string
					{
						l := len([]byte(v))
						tmpp += 1 + tygo.SizeVarint(uint64(l)) + l
					}
				// variant type size: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						tmppp := v.CachedSize()
						tmpp += 1 + tygo.SizeVarint(uint64(tmppp)) + tmppp
					}
				// addition type size: int -> float64
				case int:
					tmpp += 9
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
				output.WriteBytes(18) // tag: 18 MAKE_TAG(2, WireBytes=2)
				output.WriteVarint(uint64(tmpp))
				switch v := v.(type) {
				// variant type serialize: Corpus
				case Corpus:
					// type: Corpus
					output.WriteBytes(8) // tag: 8 MAKE_TAG(1, WireVarint=0)
					output.WriteVarint(uint64(v))
				// variant type serialize: float64
				case float64:
					// type: float64
					output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
					output.WriteFixed64(math.Float64bits(v))
				// variant type serialize: string
				case string:
					// type: string
					{
						output.WriteBytes(26) // tag: 26 MAKE_TAG(3, WireBytes=2)
						output.WriteBuf([]byte(v))
					}
				// variant type serialize: *Vector2
				case *Vector2:
					// type: *Vector2
					{
						output.WriteBytes(34) // tag: 34 MAKE_TAG(4, WireBytes=2)
						output.WriteVarint(uint64(v.CachedSize()))
						v.Serialize(output)
					}
				// addition type serialize: int -> float64
				case int:
					output.WriteBytes(17) // tag: 17 MAKE_TAG(2, WireFixed64=1)
					output.WriteFixed64(math.Float64bits(float64(v)))
				default:
					panic(fmt.Sprintf("[Tygo][Variant] Unexpect type for variant<Corpus, float64, string, *Vector2>: %v", v))
				}
			}
		}
	}

	return
}

// GPR Result(a0: map[int32]variant<Corpus, float64, string, *Vector2>)
func (s *Fighter) DeserializeGPRResult(data []byte) (a0 map[int32]interface{}, err error) {
	input := &tygo.ProtoBuf{Buffer: data}
method_tmp_36:
	for !input.ExpectEnd() {
		var tag int
		var cutoff bool
		if tag, cutoff, err = input.ReadTag(((1 << 3) | 7)); err != nil {
			return
		} else if cutoff {
			switch tag >> 3 {
			// result deserialize: a0
			case 1:
				if tag == 10 { // MAKE_TAG(1, WireBytes=2)
				loop_tmp_37:
					// type: map[int32]variant<Corpus, float64, string, *Vector2>
					for {
						if x, e := input.ReadBuf(); e == nil {
							if a0 == nil {
								a0 = make(map[int32]interface{})
							}
							tmpi := &tygo.ProtoBuf{Buffer: x}
							var tmp_37 int32
							var tmp_38 interface{}
						dict_tmp_37:
							for !tmpi.ExpectEnd() {
								var tmpg int
								var cutoff bool
								if tmpg, cutoff, err = tmpi.ReadTag(127); err != nil {
									return
								} else if cutoff {
								switch_tmp_37:
									switch tmpg >> 3 {
									// dict key
									case 1:
										if tmpg == 8 { // MAKE_TAG(1, WireVarint=0)
											// type: int32
											if x, e := tmpi.ReadVarint(); e == nil {
												tmp_37 = int32(x)
											} else {
												err = e
												return
											}
											if !tmpi.ExpectBytes(18) { // tag: 18 MAKE_TAG(2, WireBytes=2)
												continue dict_tmp_37 // next tag for map[int32]variant<Corpus, float64, string, *Vector2>
											}
											tmpg = 18 // fallthrough case 2
										} else {
											break switch_tmp_37 // skip tag
										}
										fallthrough
									case 2:
										if tmpg == 18 { // MAKE_TAG(2, WireBytes=2)
											// type: variant<Corpus, float64, string, *Vector2>
											if x, e := tmpi.ReadBuf(); e == nil {
												tmpii := &tygo.ProtoBuf{Buffer: x}
											variant_tmp_39:
												for !tmpii.ExpectEnd() {
													var tmpig int
													var cutoff bool
													if tmpig, cutoff, err = tmpii.ReadTag(127); err != nil {
														return
													} else if cutoff {
														switch tmpig >> 3 {
														case 1:
															if tmpig == 8 { // MAKE_TAG(1, WireVarint=0)
																// type: Corpus
																if x, e := tmpii.ReadVarint(); e == nil {
																	tmp_38 = Corpus(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_39 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 2:
															if tmpig == 17 { // MAKE_TAG(2, WireFixed64=1)
																// type: float64
																if x, e := tmpii.ReadFixed64(); e == nil {
																	tmp_38 = math.Float64frombits(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_39 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 3:
															if tmpig == 26 { // MAKE_TAG(3, WireBytes=2)
																// type: string
																if x, e := tmpii.ReadBuf(); e == nil {
																	tmp_38 = string(x)
																} else {
																	err = e
																	return
																}
																continue variant_tmp_39 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														case 4:
															if tmpig == 34 { // MAKE_TAG(4, WireBytes=2)
																// type: *Vector2
																if x, e := tmpii.ReadBuf(); e == nil {
																	if tmp_38 == nil {
																		tmp_38 = &Vector2{}
																	}
																	if len(x) > 0 {
																		if err = tmp_38.(*Vector2).Deserialize(&tygo.ProtoBuf{Buffer: x}); err != nil {
																			return
																		}
																	}
																} else {
																	err = e
																	return
																}
																continue variant_tmp_39 // next tag for variant<Corpus, float64, string, *Vector2>
															}
														}
													}
													if err = tmpii.SkipField(tmpig); err != nil {
														return
													}
												}
											} else {
												err = e
												return
											}
											if tmpi.ExpectEnd() {
												break dict_tmp_37 // end for map[int32]variant<Corpus, float64, string, *Vector2>
											}
											continue dict_tmp_37 // next tag for map[int32]variant<Corpus, float64, string, *Vector2>
										}
									}
								}
								if err = tmpi.SkipField(tmpg); err != nil {
									return
								}
							}
							a0[tmp_37] = tmp_38
						} else {
							err = e
							return
						}
						if !input.ExpectBytes(10) { // tag: 10 MAKE_TAG(1, WireBytes=2)
							break loop_tmp_37 // end for map[int32]variant<Corpus, float64, string, *Vector2>
						}
					}
					if input.ExpectEnd() {
						break method_tmp_36 // end for result
					}
					continue method_tmp_36 // next tag for result
				}
			}
		}
		if err = input.SkipField(tag); err != nil {
			return
		}
	}
	return
}
