// Copyright 2017 ibelie, Chen Jie, Joungtao. All rights reserved.
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package tygo

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"

	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"io/ioutil"
)

const (
	goHeader = `// Generated by tygo.  DO NOT EDIT!

package %s

`
	goImport = `import %s"%s"
`
)

var SRC_PATH = os.Getenv("GOPATH") + "/src/"

func Inject(path string) {
	buildPackage, err := build.Import(path, "", build.ImportComment)
	if err != nil {
		panic(fmt.Sprintf("[Tygo][Inject] Cannot import package:\n>>>>%v", err))
		return
	}
	fs := token.NewFileSet()
	for _, filename := range buildPackage.GoFiles {
		if strings.HasSuffix(filename, ".ty.go") {
			continue
		}
		file, err := parser.ParseFile(fs, buildPackage.Dir+"/"+filename, nil, parser.ParseComments)
		if err != nil {
			panic(fmt.Sprintf("[Tygo][Inject] Cannot parse file:\n>>>>%v", err))
		}
		for _, d := range file.Decls {
			decl, ok := d.(*ast.GenDecl)
			if !ok || decl.Tok != token.IMPORT {
				continue
			}
			for _, s := range decl.Specs {
				spec, ok := s.(*ast.ImportSpec)
				if !ok || spec.Path.Value != "\"github.com/ibelie/tygo\"" {
					continue
				}
				injectfile := SRC_PATH + path + "/" + strings.Replace(filename, ".go", ".ty.go", 1)
				if strings.TrimSpace(decl.Doc.Text()) == "" {
					os.Remove(injectfile)
				} else {
					inject(injectfile, decl.Doc.Text(), file)
				}
			}
		}
	}
}

func inject(filename string, doc string, file *ast.File) {
	imports := make(map[string]string)
	for _, importSpec := range file.Imports {
		pkg := strings.Trim(importSpec.Path.Value, "\"")
		if importSpec.Name == nil {
			if p, err := build.Import(pkg, "", build.AllowBinary); err != nil {
				panic(fmt.Sprintf("[Tygo][Inject] Cannot import package:\n>>>>%v", err))
			} else {
				imports[p.Name] = pkg
			}
		} else {
			imports[importSpec.Name.Name] = pkg
		}
	}
	types := Parse(doc, imports)

	var head bytes.Buffer
	var body bytes.Buffer
	head.Write([]byte(fmt.Sprintf(goHeader, file.Name)))

	imported := map[string]bool{}
	for _, t := range types {
		code, pkgs := t.Go()
		for _, pkg := range pkgs {
			if i, ok := imported[pkg[1]]; !ok || !i {
				head.Write([]byte(fmt.Sprintf(goImport, pkg[0], pkg[1])))
				imported[pkg[1]] = true
			}
		}
		body.Write([]byte(code))
	}

	head.Write(body.Bytes())
	ioutil.WriteFile(filename, head.Bytes(), 0666)
}

func (t *Enum) Go() (string, [][2]string) {
	var values []string
	var names []string
	for _, name := range t.Sorted() {
		values = append(values, fmt.Sprintf(`
	%s_%s %s%s = %d`, t.Name, name, strings.Repeat(" ", t.nameMax-len(name)), t.Name, t.Values[name]))
		names = append(names, fmt.Sprintf(`
	case %s_%s:
		return "%s"`, t.Name, name, name))
	}
	return fmt.Sprintf(`
type %s int

const (%s
)

func (i %s) String() string {
	switch i {%s
	default:
		log.Fatalf("[Tygo][%s] Unexpect enum value: %%d", i)
		return "UNKNOWN"
	}
}
`, t.Name, strings.Join(values, ""), t.Name, strings.Join(names, ""), t.Name), [][2]string{[2]string{"", "log"}}
}

func (t *Object) Go() (string, [][2]string) {
	var fields []string
	var pkgs [][2]string

	var sortedParent []string
	for _, parent := range t.Parents {
		s, p := parent.Go()
		sortedParent = append(sortedParent, s)
		pkgs = append(pkgs, p...)
	}
	sort.Strings(sortedParent)
	for _, parent := range sortedParent {
		fields = append(fields, fmt.Sprintf(`
	%s`, parent))
	}

	nameMax := 0
	var sortedField []string
	for name, _ := range t.Fields {
		if nameMax < len(name) {
			nameMax = len(name)
		}
		sortedField = append(sortedField, name)
	}
	sort.Strings(sortedField)
	for _, name := range sortedField {
		s, p := t.Fields[name].Go()
		pkgs = append(pkgs, p...)
		fields = append(fields, fmt.Sprintf(`
	%s %s%s`, name, strings.Repeat(" ", nameMax-len(name)), s))
	}

	pkgDict := make(map[string]string)
	var sortedPkg []string
	for _, pkg := range pkgs {
		sortedPkg = append(sortedPkg, pkg[1])
		pkgDict[pkg[1]] = pkg[0]
	}
	sort.Strings(sortedPkg)
	pkgs = nil
	for _, pkg := range sortedPkg {
		pkgs = append(pkgs, [2]string{pkgDict[pkg], pkg})
	}

	return fmt.Sprintf(`
type %s struct {%s
}
`, t.Name, strings.Join(fields, "")), pkgs
}

func (t SimpleType) Go() (string, [][2]string) {
	if string(t) == "bytes" {
		return "[]byte", nil
	}
	return string(t), nil
}

func (t *ObjectType) Go() (string, [][2]string) {
	if t.PkgPath == "" {
		return t.String(), nil
	} else {
		s := ""
		if t.IsPtr {
			s += "*"
		}
		var a string
		if p, err := build.Import(t.PkgPath, "", build.AllowBinary); err == nil && p.Name == t.PkgName {
			a = ""
		} else {
			a = t.PkgName + " "
		}
		return s + t.PkgName + "." + t.Name, [][2]string{[2]string{a, t.PkgPath}}
	}
}

func (t *FixedPointType) Go() (string, [][2]string) {
	return "float64", nil
}

func (t *ListType) Go() (string, [][2]string) {
	s, p := t.E.Go()
	return fmt.Sprintf("[]%s", s), p
}

func (t *DictType) Go() (string, [][2]string) {
	ks, kp := t.K.Go()
	vs, vp := t.V.Go()
	return fmt.Sprintf("map[%s]%s", ks, vs), append(kp, vp...)
}

func (t *VariantType) Go() (string, [][2]string) {
	var p [][2]string
	for _, vt := range t.Ts {
		_, vp := vt.Go()
		p = append(p, vp...)
	}
	return "interface{}", p
}
