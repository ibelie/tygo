// Copyright 2017 ibelie, Chen Jie, Joungtao. All rights reserved.
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package tygo

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"

	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"io/ioutil"
)

const (
	goHeader = `// Generated by tygo.  DO NOT EDIT!

package %s

`
	goImport = `import %s %s
`
)

var SRC_PATH = os.Getenv("GOPATH") + "/src/"

func Inject(path string) {
	buildPackage, err := build.Import(path, "", build.ImportComment)
	if err != nil {
		panic(fmt.Sprintf("[Tygo][Inject] Cannot import package:\n>>>>%v", err))
		return
	}
	fs := token.NewFileSet()
	for _, filename := range buildPackage.GoFiles {
		if strings.HasSuffix(filename, ".ty.go") {
			continue
		}
		file, err := parser.ParseFile(fs, buildPackage.Dir+"/"+filename, nil, parser.ParseComments)
		if err != nil {
			panic(fmt.Sprintf("[Tygo][Inject] Cannot parse file:\n>>>>%v", err))
		}
		for _, d := range file.Decls {
			decl, ok := d.(*ast.GenDecl)
			if !ok || decl.Tok != token.IMPORT {
				continue
			}
			for _, s := range decl.Specs {
				spec, ok := s.(*ast.ImportSpec)
				if !ok || spec.Path.Value != "\"github.com/ibelie/tygo\"" {
					continue
				}
				injectfile := SRC_PATH + path + "/" + strings.Replace(filename, ".go", ".ty.go", 1)
				if strings.TrimSpace(decl.Doc.Text()) == "" {
					os.Remove(injectfile)
				} else {
					inject(injectfile, decl.Doc.Text(), file)
				}
			}
		}
	}
}

const (
	goEnum = `
type %s int

const (%s
)

func (i %s) String() {
	switch i {%s
	default:
		log.Fatalf("[Tygo][%s] Unexpect enum value: %%d", i)
	}
}
`
	goObject = `
type %s struct {%s
}
`
)

func inject(filename string, doc string, file *ast.File) {
	imports := make(map[string]string)
	for _, importSpec := range file.Imports {
		if importSpec.Name == nil {
			p := strings.Split(importSpec.Path.Value, "/")
			imports[strings.TrimRight(p[len(p)-1], "\"")] = importSpec.Path.Value
		} else {
			imports[importSpec.Name.Name] = importSpec.Path.Value
		}
	}
	enums, objects := Parse(imports, doc)

	var head bytes.Buffer
	var body bytes.Buffer
	head.Write([]byte(fmt.Sprintf(goHeader, file.Name)))

	for _, enum := range enums {
		var values []string
		var names []string
		var sortedValue []int
		valueMap := map[int]string{}
		nameMax := 0
		for name, value := range enum.Values {
			if nameMax < len(name) {
				nameMax = len(name)
			}
			valueMap[value] = name
			sortedValue = append(sortedValue, value)
		}
		sort.Ints(sortedValue)
		for _, value := range sortedValue {
			name := valueMap[value]
			values = append(values, fmt.Sprintf(`
	%s_%s %s%s = %d`, enum.Name, name, strings.Repeat(" ", nameMax-len(name)), enum.Name, value))
			names = append(names, fmt.Sprintf(`
	case %s_%s:
		return "%s"`, enum.Name, name, name))
		}
		body.Write([]byte(fmt.Sprintf(goEnum, enum.Name, strings.Join(values, ""), enum.Name, strings.Join(names, ""), enum.Name)))
	}

	for _, object := range objects {
		var fields []string
		body.Write([]byte(fmt.Sprintf(goObject, object.Name, strings.Join(fields, ""))))
	}

	head.Write(body.Bytes())
	ioutil.WriteFile(filename, head.Bytes(), 0666)
}
