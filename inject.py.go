// Copyright 2017 ibelie, Chen Jie, Joungtao. All rights reserved.
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package tygo

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"path"
	"strings"

	"io/ioutil"
)

var (
	PY_WRITER  io.Writer
	PY_TYPES   map[string]bool
	PY_OBJECTS map[string]*Object
)

func Python(dir string, name string, types []Type, propPre []Type) {
	var buffer bytes.Buffer

	PROP_PRE = propPre
	PY_WRITER = &buffer
	PY_OBJECTS = ObjectMap(types)
	PY_TYPES = make(map[string]bool)
	var codes []string
	for _, t := range types {
		codes = append(codes, t.Python())
	}
	PROP_PRE = nil
	PY_TYPES = nil
	PY_WRITER = nil
	PY_OBJECTS = nil

	buffer.Write([]byte(fmt.Sprintf(`#-*- coding: utf-8 -*-
# Generated by ibelie-rpc.  DO NOT EDIT!

import typy

%s
`, strings.Join(codes, ""))))

	ioutil.WriteFile(path.Join(dir, name+".py"), buffer.Bytes(), 0666)
}

func (t *Enum) Python() string {
	var enums []string
	for _, name := range t.Sorted() {
		enums = append(enums, fmt.Sprintf(`
	%s = %d, "%s"`, name, t.Values[name], name))
	}
	return fmt.Sprintf(`
class %s(typy.Enum):%s
`, t.Name, strings.Join(enums, ""))
}

func fieldsPython(name string, parent string, fs []*Field) string {
	if ok, exist := PY_TYPES[name]; exist && ok {
		return ""
	}

	PY_TYPES[name] = true
	var fields []string
	var sequences []string
	for _, f := range fs {
		sequences = append(sequences, fmt.Sprintf("'%s'", f.Name))
		fields = append(fields, fmt.Sprintf(`
	%s = %s`, f.Name, strings.Replace(f.Python(), "typy.", "typy.pb.", 1)))
	}

	var sequence string
	if sequences == nil {
		return ""
	} else if len(sequences) > 1 {
		sequence = fmt.Sprintf(`
	____propertySequence__ = %s`, strings.Join(sequences, ", "))
	}

	return fmt.Sprintf(`
class %s(%s):%s%s
`, name, parent, sequence, strings.Join(fields, ""))
}

func (t *Object) Python() string {
	var objects []string
	parent := "typy.Object"
	if t.HasParent() {
		parent = t.Parent.Name
	}
	objects = append(objects, fieldsPython(t.Name, parent, t.VisibleFields()))

	if PROP_PRE != nil {
		for _, field := range t.VisibleFields() {
			objects = append(objects, fieldsPython(fmt.Sprintf("%s_%s", t.Name, field.Name),
				"typy.Object", []*Field{field}))
		}
	}

	for _, method := range t.Methods {
		if len(method.Params) > 0 {
			var params []*Field
			for i, p := range method.Params {
				params = append(params, &Field{Type: p, Name: fmt.Sprintf("a%d", i)})
			}
			objects = append(objects, fieldsPython(fmt.Sprintf("%s_%sParam", t.Name, method.Name),
				"typy.Object", params))
		}
		if len(method.Results) > 0 {
			var results []*Field
			for i, r := range method.Results {
				results = append(results, &Field{Type: r, Name: fmt.Sprintf("a%d", i)})
			}
			objects = append(objects, fieldsPython(fmt.Sprintf("%s_%sResult", t.Name, method.Name),
				"typy.Object", results))
		}
	}

	return strings.Join(objects, "")
}

func (t UnknownType) Python() string {
	return ""
}

func (t SimpleType) Python() string {
	switch t {
	case SimpleType_INT32:
		fallthrough
	case SimpleType_INT64:
		fallthrough
	case SimpleType_UINT32:
		fallthrough
	case SimpleType_UINT64:
		return "typy.Integer"
	case SimpleType_FLOAT32:
		fallthrough
	case SimpleType_FLOAT64:
		return "typy.Float"
	case SimpleType_BYTES:
		return "typy.Bytes"
	case SimpleType_STRING:
		return "typy.String"
	case SimpleType_BOOL:
		return "typy.Boolean"
	default:
		log.Fatalf("[Tygo][SimpleType] Unexpect enum value for Python: %d", t)
		return "Unknown"
	}
}

func (t *EnumType) Python() string {
	PY_WRITER.Write([]byte(t.Enum.Python()))
	return fmt.Sprintf("typy.Enum(%s)", t.Name)
}

func (t *InstanceType) Python() string {
	if object, ok := TS_OBJECTS[t.Name]; ok {
		PY_WRITER.Write([]byte(object.Python()))
		return fmt.Sprintf("typy.Instance(%s)", t.Name)
	} else {
		return fmt.Sprintf("typy.Python(%s)", t.Name)
	}
}

func (t *FixedPointType) Python() string {
	return fmt.Sprintf("typy.FixedPoint(%d, %d)", t.Precision, t.Floor)
}

func (t *ListType) Python() string {
	return fmt.Sprintf("typy.List(%s)", t.E.Python())
}

func (t *DictType) Python() string {
	return fmt.Sprintf("typy.Dict(%s, %s)", t.K.Python(), t.V.Python())
}

func (t *VariantType) Python() string {
	var variants []string
	for _, v := range t.Ts {
		if inst, ok := v.(*InstanceType); ok {
			if object, ok := TS_OBJECTS[inst.Name]; ok {
				PY_WRITER.Write([]byte(object.Python()))
				variants = append(variants, inst.Name)
				continue
			}
		}
		variants = append(variants, v.Python())
	}
	return fmt.Sprintf("typy.Instance(%s)", strings.Join(variants, ", "))
}

func Typyd(dir string, name string, types []Type, propPre []Type) {
	var buffer bytes.Buffer

	PROP_PRE = propPre
	PY_OBJECTS = ObjectMap(types)
	var codes []string
	// for _, t := range types {
	// 	codes = append(codes, t.Typyd())
	// }
	PROP_PRE = nil
	PY_OBJECTS = nil

	buffer.Write([]byte(fmt.Sprintf(`#-*- coding: utf-8 -*-
# Generated by ibelie-rpc.  DO NOT EDIT!

import typy

%s
`, strings.Join(codes, ""))))

	ioutil.WriteFile(path.Join(dir, name+".py"), buffer.Bytes(), 0666)
}

func (t *Enum) Typyd() string {
	var enums []string
	for _, name := range t.Sorted() {
		enums = append(enums, fmt.Sprintf(`
		%s = %d`, name, t.Values[name]))
	}
	return fmt.Sprintf(`

	const enum %s {%s
	}`, t.Name, strings.Join(enums, ","))
}

func (t *Object) Typyd() string {
	var parent string
	if t.HasParent() {
		parent = fmt.Sprintf(" extends %s", t.Parent.Typyd())
	}
	var members []string
	for _, field := range t.VisibleFields() {
		members = append(members, fmt.Sprintf(`
		%s: %s;`, field.Name, field.Typyd()))
	}

	if PROP_PRE != nil {
		for _, field := range t.VisibleFields() {
			members = append(members, field.Python())
			// members = append(members, typeListPython(field.Name, "", []Type{field}))
		}
	}

	for _, method := range t.Methods {
		if len(method.Params) > 0 {
			// members = append(members, typeListPython(method.Name, "Param", method.Params))
		}
		if len(method.Results) > 0 {
			// members = append(members, typeListPython(method.Name, "Result", method.Results))
		}
	}

	return fmt.Sprintf(`

	class %s%s {
		__class__: string;
		ByteSize(): number;
		Serialize(): Uint8Array;
		Deserialize(data: Uint8Array): void;
%s
	}

	namespace %s {
		function Deserialize(data: Uint8Array): %s;
	}`, t.Name, parent, strings.Join(members, ""), t.Name, t.Name)
}

func (t UnknownType) Typyd() string {
	return ""
}

func (t SimpleType) Typyd() string {
	switch t {
	case SimpleType_INT32:
		fallthrough
	case SimpleType_INT64:
		fallthrough
	case SimpleType_UINT32:
		fallthrough
	case SimpleType_UINT64:
		fallthrough
	case SimpleType_FLOAT32:
		fallthrough
	case SimpleType_FLOAT64:
		return "number"
	case SimpleType_BYTES:
		return "Uint8Array"
	case SimpleType_STRING:
		return "string"
	case SimpleType_BOOL:
		return "boolean"
	default:
		log.Fatalf("[Tygo][SimpleType] Unexpect enum value for Typyd: %d", t)
		return "unknown"
	}
}

func (t *EnumType) Typyd() string {
	return t.Name
}

func (t *InstanceType) Typyd() string {
	if _, ok := TS_OBJECTS[t.Name]; ok {
		return t.Name
	} else {
		return "Type"
	}
}

func (t *FixedPointType) Typyd() string {
	return "number"
}

func (t *ListType) Typyd() string {
	return fmt.Sprintf("%s[]", t.E.Typyd())
}

func (t *DictType) Typyd() string {
	return fmt.Sprintf("{[index: %s]: %s}", t.K.Typyd(), t.V.Typyd())
}

func (t *VariantType) Typyd() string {
	return "any"
}
